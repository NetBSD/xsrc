/* This file is generated by venus-protocol.  See vn_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: MIT
 */

#ifndef VN_PROTOCOL_DRIVER_STRUCTS_H
#define VN_PROTOCOL_DRIVER_STRUCTS_H

#include "vn_protocol_driver_handles.h"

/*
 * These structs/unions/commands are not included
 *
 *   VkAllocationCallbacks
 */

/* struct VkExtent3D */

static inline size_t
vn_sizeof_VkExtent3D(const VkExtent3D *val)
{
    size_t size = 0;
    size += vn_sizeof_uint32_t(&val->width);
    size += vn_sizeof_uint32_t(&val->height);
    size += vn_sizeof_uint32_t(&val->depth);
    return size;
}

static inline void
vn_encode_VkExtent3D(struct vn_cs_encoder *enc, const VkExtent3D *val)
{
    vn_encode_uint32_t(enc, &val->width);
    vn_encode_uint32_t(enc, &val->height);
    vn_encode_uint32_t(enc, &val->depth);
}

static inline void
vn_decode_VkExtent3D(struct vn_cs_decoder *dec, VkExtent3D *val)
{
    vn_decode_uint32_t(dec, &val->width);
    vn_decode_uint32_t(dec, &val->height);
    vn_decode_uint32_t(dec, &val->depth);
}

static inline size_t
vn_sizeof_VkExtent3D_partial(const VkExtent3D *val)
{
    size_t size = 0;
    /* skip val->width */
    /* skip val->height */
    /* skip val->depth */
    return size;
}

static inline void
vn_encode_VkExtent3D_partial(struct vn_cs_encoder *enc, const VkExtent3D *val)
{
    /* skip val->width */
    /* skip val->height */
    /* skip val->depth */
}

/* struct VkLayerProperties */

static inline size_t
vn_sizeof_VkLayerProperties(const VkLayerProperties *val)
{
    size_t size = 0;
    size += vn_sizeof_array_size(VK_MAX_EXTENSION_NAME_SIZE);
    size += vn_sizeof_char_array(val->layerName, VK_MAX_EXTENSION_NAME_SIZE);
    size += vn_sizeof_uint32_t(&val->specVersion);
    size += vn_sizeof_uint32_t(&val->implementationVersion);
    size += vn_sizeof_array_size(VK_MAX_DESCRIPTION_SIZE);
    size += vn_sizeof_char_array(val->description, VK_MAX_DESCRIPTION_SIZE);
    return size;
}

static inline void
vn_decode_VkLayerProperties(struct vn_cs_decoder *dec, VkLayerProperties *val)
{
    {
        const size_t array_size = vn_decode_array_size(dec, VK_MAX_EXTENSION_NAME_SIZE);
        vn_decode_char_array(dec, val->layerName, array_size);
    }
    vn_decode_uint32_t(dec, &val->specVersion);
    vn_decode_uint32_t(dec, &val->implementationVersion);
    {
        const size_t array_size = vn_decode_array_size(dec, VK_MAX_DESCRIPTION_SIZE);
        vn_decode_char_array(dec, val->description, array_size);
    }
}

static inline size_t
vn_sizeof_VkLayerProperties_partial(const VkLayerProperties *val)
{
    size_t size = 0;
    /* skip val->layerName */
    /* skip val->specVersion */
    /* skip val->implementationVersion */
    /* skip val->description */
    return size;
}

static inline void
vn_encode_VkLayerProperties_partial(struct vn_cs_encoder *enc, const VkLayerProperties *val)
{
    /* skip val->layerName */
    /* skip val->specVersion */
    /* skip val->implementationVersion */
    /* skip val->description */
}

/* struct VkExtensionProperties */

static inline size_t
vn_sizeof_VkExtensionProperties(const VkExtensionProperties *val)
{
    size_t size = 0;
    size += vn_sizeof_array_size(VK_MAX_EXTENSION_NAME_SIZE);
    size += vn_sizeof_char_array(val->extensionName, VK_MAX_EXTENSION_NAME_SIZE);
    size += vn_sizeof_uint32_t(&val->specVersion);
    return size;
}

static inline void
vn_encode_VkExtensionProperties(struct vn_cs_encoder *enc, const VkExtensionProperties *val)
{
    vn_encode_array_size(enc, VK_MAX_EXTENSION_NAME_SIZE);
    vn_encode_char_array(enc, val->extensionName, VK_MAX_EXTENSION_NAME_SIZE);
    vn_encode_uint32_t(enc, &val->specVersion);
}

static inline void
vn_decode_VkExtensionProperties(struct vn_cs_decoder *dec, VkExtensionProperties *val)
{
    {
        const size_t array_size = vn_decode_array_size(dec, VK_MAX_EXTENSION_NAME_SIZE);
        vn_decode_char_array(dec, val->extensionName, array_size);
    }
    vn_decode_uint32_t(dec, &val->specVersion);
}

static inline size_t
vn_sizeof_VkExtensionProperties_partial(const VkExtensionProperties *val)
{
    size_t size = 0;
    /* skip val->extensionName */
    /* skip val->specVersion */
    return size;
}

static inline void
vn_encode_VkExtensionProperties_partial(struct vn_cs_encoder *enc, const VkExtensionProperties *val)
{
    /* skip val->extensionName */
    /* skip val->specVersion */
}

/* struct VkMemoryRequirements */

static inline size_t
vn_sizeof_VkMemoryRequirements(const VkMemoryRequirements *val)
{
    size_t size = 0;
    size += vn_sizeof_VkDeviceSize(&val->size);
    size += vn_sizeof_VkDeviceSize(&val->alignment);
    size += vn_sizeof_uint32_t(&val->memoryTypeBits);
    return size;
}

static inline void
vn_decode_VkMemoryRequirements(struct vn_cs_decoder *dec, VkMemoryRequirements *val)
{
    vn_decode_VkDeviceSize(dec, &val->size);
    vn_decode_VkDeviceSize(dec, &val->alignment);
    vn_decode_uint32_t(dec, &val->memoryTypeBits);
}

static inline size_t
vn_sizeof_VkMemoryRequirements_partial(const VkMemoryRequirements *val)
{
    size_t size = 0;
    /* skip val->size */
    /* skip val->alignment */
    /* skip val->memoryTypeBits */
    return size;
}

static inline void
vn_encode_VkMemoryRequirements_partial(struct vn_cs_encoder *enc, const VkMemoryRequirements *val)
{
    /* skip val->size */
    /* skip val->alignment */
    /* skip val->memoryTypeBits */
}

/* struct VkSparseImageFormatProperties */

static inline size_t
vn_sizeof_VkSparseImageFormatProperties(const VkSparseImageFormatProperties *val)
{
    size_t size = 0;
    size += vn_sizeof_VkFlags(&val->aspectMask);
    size += vn_sizeof_VkExtent3D(&val->imageGranularity);
    size += vn_sizeof_VkFlags(&val->flags);
    return size;
}

static inline void
vn_decode_VkSparseImageFormatProperties(struct vn_cs_decoder *dec, VkSparseImageFormatProperties *val)
{
    vn_decode_VkFlags(dec, &val->aspectMask);
    vn_decode_VkExtent3D(dec, &val->imageGranularity);
    vn_decode_VkFlags(dec, &val->flags);
}

static inline size_t
vn_sizeof_VkSparseImageFormatProperties_partial(const VkSparseImageFormatProperties *val)
{
    size_t size = 0;
    /* skip val->aspectMask */
    size += vn_sizeof_VkExtent3D_partial(&val->imageGranularity);
    /* skip val->flags */
    return size;
}

static inline void
vn_encode_VkSparseImageFormatProperties_partial(struct vn_cs_encoder *enc, const VkSparseImageFormatProperties *val)
{
    /* skip val->aspectMask */
    vn_encode_VkExtent3D_partial(enc, &val->imageGranularity);
    /* skip val->flags */
}

/* struct VkImageSubresource */

static inline size_t
vn_sizeof_VkImageSubresource(const VkImageSubresource *val)
{
    size_t size = 0;
    size += vn_sizeof_VkFlags(&val->aspectMask);
    size += vn_sizeof_uint32_t(&val->mipLevel);
    size += vn_sizeof_uint32_t(&val->arrayLayer);
    return size;
}

static inline void
vn_encode_VkImageSubresource(struct vn_cs_encoder *enc, const VkImageSubresource *val)
{
    vn_encode_VkFlags(enc, &val->aspectMask);
    vn_encode_uint32_t(enc, &val->mipLevel);
    vn_encode_uint32_t(enc, &val->arrayLayer);
}

/* struct VkOffset3D */

static inline size_t
vn_sizeof_VkOffset3D(const VkOffset3D *val)
{
    size_t size = 0;
    size += vn_sizeof_int32_t(&val->x);
    size += vn_sizeof_int32_t(&val->y);
    size += vn_sizeof_int32_t(&val->z);
    return size;
}

static inline void
vn_encode_VkOffset3D(struct vn_cs_encoder *enc, const VkOffset3D *val)
{
    vn_encode_int32_t(enc, &val->x);
    vn_encode_int32_t(enc, &val->y);
    vn_encode_int32_t(enc, &val->z);
}

/* struct VkSemaphoreTypeCreateInfo chain */

static inline size_t
vn_sizeof_VkSemaphoreTypeCreateInfo_pnext(const void *val)
{
    /* no known/supported struct */
    return vn_sizeof_simple_pointer(NULL);
}

static inline size_t
vn_sizeof_VkSemaphoreTypeCreateInfo_self(const VkSemaphoreTypeCreateInfo *val)
{
    size_t size = 0;
    /* skip val->{sType,pNext} */
    size += vn_sizeof_VkSemaphoreType(&val->semaphoreType);
    size += vn_sizeof_uint64_t(&val->initialValue);
    return size;
}

static inline size_t
vn_sizeof_VkSemaphoreTypeCreateInfo(const VkSemaphoreTypeCreateInfo *val)
{
    size_t size = 0;

    size += vn_sizeof_VkStructureType(&val->sType);
    size += vn_sizeof_VkSemaphoreTypeCreateInfo_pnext(val->pNext);
    size += vn_sizeof_VkSemaphoreTypeCreateInfo_self(val);

    return size;
}

static inline void
vn_encode_VkSemaphoreTypeCreateInfo_pnext(struct vn_cs_encoder *enc, const void *val)
{
    /* no known/supported struct */
    vn_encode_simple_pointer(enc, NULL);
}

static inline void
vn_encode_VkSemaphoreTypeCreateInfo_self(struct vn_cs_encoder *enc, const VkSemaphoreTypeCreateInfo *val)
{
    /* skip val->{sType,pNext} */
    vn_encode_VkSemaphoreType(enc, &val->semaphoreType);
    vn_encode_uint64_t(enc, &val->initialValue);
}

static inline void
vn_encode_VkSemaphoreTypeCreateInfo(struct vn_cs_encoder *enc, const VkSemaphoreTypeCreateInfo *val)
{
    assert(val->sType == VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO);
    vn_encode_VkStructureType(enc, &(VkStructureType){ VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO });
    vn_encode_VkSemaphoreTypeCreateInfo_pnext(enc, val->pNext);
    vn_encode_VkSemaphoreTypeCreateInfo_self(enc, val);
}

/* struct VkImageFormatListCreateInfo chain */

static inline size_t
vn_sizeof_VkImageFormatListCreateInfo_pnext(const void *val)
{
    /* no known/supported struct */
    return vn_sizeof_simple_pointer(NULL);
}

static inline size_t
vn_sizeof_VkImageFormatListCreateInfo_self(const VkImageFormatListCreateInfo *val)
{
    size_t size = 0;
    /* skip val->{sType,pNext} */
    size += vn_sizeof_uint32_t(&val->viewFormatCount);
    if (val->pViewFormats) {
        size += vn_sizeof_array_size(val->viewFormatCount);
        size += vn_sizeof_VkFormat_array(val->pViewFormats, val->viewFormatCount);
    } else {
        size += vn_sizeof_array_size(0);
    }
    return size;
}

static inline size_t
vn_sizeof_VkImageFormatListCreateInfo(const VkImageFormatListCreateInfo *val)
{
    size_t size = 0;

    size += vn_sizeof_VkStructureType(&val->sType);
    size += vn_sizeof_VkImageFormatListCreateInfo_pnext(val->pNext);
    size += vn_sizeof_VkImageFormatListCreateInfo_self(val);

    return size;
}

static inline void
vn_encode_VkImageFormatListCreateInfo_pnext(struct vn_cs_encoder *enc, const void *val)
{
    /* no known/supported struct */
    vn_encode_simple_pointer(enc, NULL);
}

static inline void
vn_encode_VkImageFormatListCreateInfo_self(struct vn_cs_encoder *enc, const VkImageFormatListCreateInfo *val)
{
    /* skip val->{sType,pNext} */
    vn_encode_uint32_t(enc, &val->viewFormatCount);
    if (val->pViewFormats) {
        vn_encode_array_size(enc, val->viewFormatCount);
        vn_encode_VkFormat_array(enc, val->pViewFormats, val->viewFormatCount);
    } else {
        vn_encode_array_size(enc, 0);
    }
}

static inline void
vn_encode_VkImageFormatListCreateInfo(struct vn_cs_encoder *enc, const VkImageFormatListCreateInfo *val)
{
    assert(val->sType == VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO);
    vn_encode_VkStructureType(enc, &(VkStructureType){ VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO });
    vn_encode_VkImageFormatListCreateInfo_pnext(enc, val->pNext);
    vn_encode_VkImageFormatListCreateInfo_self(enc, val);
}

/* struct VkImageStencilUsageCreateInfo chain */

static inline size_t
vn_sizeof_VkImageStencilUsageCreateInfo_pnext(const void *val)
{
    /* no known/supported struct */
    return vn_sizeof_simple_pointer(NULL);
}

static inline size_t
vn_sizeof_VkImageStencilUsageCreateInfo_self(const VkImageStencilUsageCreateInfo *val)
{
    size_t size = 0;
    /* skip val->{sType,pNext} */
    size += vn_sizeof_VkFlags(&val->stencilUsage);
    return size;
}

static inline size_t
vn_sizeof_VkImageStencilUsageCreateInfo(const VkImageStencilUsageCreateInfo *val)
{
    size_t size = 0;

    size += vn_sizeof_VkStructureType(&val->sType);
    size += vn_sizeof_VkImageStencilUsageCreateInfo_pnext(val->pNext);
    size += vn_sizeof_VkImageStencilUsageCreateInfo_self(val);

    return size;
}

static inline void
vn_encode_VkImageStencilUsageCreateInfo_pnext(struct vn_cs_encoder *enc, const void *val)
{
    /* no known/supported struct */
    vn_encode_simple_pointer(enc, NULL);
}

static inline void
vn_encode_VkImageStencilUsageCreateInfo_self(struct vn_cs_encoder *enc, const VkImageStencilUsageCreateInfo *val)
{
    /* skip val->{sType,pNext} */
    vn_encode_VkFlags(enc, &val->stencilUsage);
}

static inline void
vn_encode_VkImageStencilUsageCreateInfo(struct vn_cs_encoder *enc, const VkImageStencilUsageCreateInfo *val)
{
    assert(val->sType == VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO);
    vn_encode_VkStructureType(enc, &(VkStructureType){ VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO });
    vn_encode_VkImageStencilUsageCreateInfo_pnext(enc, val->pNext);
    vn_encode_VkImageStencilUsageCreateInfo_self(enc, val);
}

/* struct VkComponentMapping */

static inline size_t
vn_sizeof_VkComponentMapping(const VkComponentMapping *val)
{
    size_t size = 0;
    size += vn_sizeof_VkComponentSwizzle(&val->r);
    size += vn_sizeof_VkComponentSwizzle(&val->g);
    size += vn_sizeof_VkComponentSwizzle(&val->b);
    size += vn_sizeof_VkComponentSwizzle(&val->a);
    return size;
}

static inline void
vn_encode_VkComponentMapping(struct vn_cs_encoder *enc, const VkComponentMapping *val)
{
    vn_encode_VkComponentSwizzle(enc, &val->r);
    vn_encode_VkComponentSwizzle(enc, &val->g);
    vn_encode_VkComponentSwizzle(enc, &val->b);
    vn_encode_VkComponentSwizzle(enc, &val->a);
}

static inline void
vn_decode_VkComponentMapping(struct vn_cs_decoder *dec, VkComponentMapping *val)
{
    vn_decode_VkComponentSwizzle(dec, &val->r);
    vn_decode_VkComponentSwizzle(dec, &val->g);
    vn_decode_VkComponentSwizzle(dec, &val->b);
    vn_decode_VkComponentSwizzle(dec, &val->a);
}

static inline size_t
vn_sizeof_VkComponentMapping_partial(const VkComponentMapping *val)
{
    size_t size = 0;
    /* skip val->r */
    /* skip val->g */
    /* skip val->b */
    /* skip val->a */
    return size;
}

static inline void
vn_encode_VkComponentMapping_partial(struct vn_cs_encoder *enc, const VkComponentMapping *val)
{
    /* skip val->r */
    /* skip val->g */
    /* skip val->b */
    /* skip val->a */
}

/* struct VkImageSubresourceRange */

static inline size_t
vn_sizeof_VkImageSubresourceRange(const VkImageSubresourceRange *val)
{
    size_t size = 0;
    size += vn_sizeof_VkFlags(&val->aspectMask);
    size += vn_sizeof_uint32_t(&val->baseMipLevel);
    size += vn_sizeof_uint32_t(&val->levelCount);
    size += vn_sizeof_uint32_t(&val->baseArrayLayer);
    size += vn_sizeof_uint32_t(&val->layerCount);
    return size;
}

static inline void
vn_encode_VkImageSubresourceRange(struct vn_cs_encoder *enc, const VkImageSubresourceRange *val)
{
    vn_encode_VkFlags(enc, &val->aspectMask);
    vn_encode_uint32_t(enc, &val->baseMipLevel);
    vn_encode_uint32_t(enc, &val->levelCount);
    vn_encode_uint32_t(enc, &val->baseArrayLayer);
    vn_encode_uint32_t(enc, &val->layerCount);
}

/* struct VkSamplerYcbcrConversionInfo chain */

static inline size_t
vn_sizeof_VkSamplerYcbcrConversionInfo_pnext(const void *val)
{
    /* no known/supported struct */
    return vn_sizeof_simple_pointer(NULL);
}

static inline size_t
vn_sizeof_VkSamplerYcbcrConversionInfo_self(const VkSamplerYcbcrConversionInfo *val)
{
    size_t size = 0;
    /* skip val->{sType,pNext} */
    size += vn_sizeof_VkSamplerYcbcrConversion(&val->conversion);
    return size;
}

static inline size_t
vn_sizeof_VkSamplerYcbcrConversionInfo(const VkSamplerYcbcrConversionInfo *val)
{
    size_t size = 0;

    size += vn_sizeof_VkStructureType(&val->sType);
    size += vn_sizeof_VkSamplerYcbcrConversionInfo_pnext(val->pNext);
    size += vn_sizeof_VkSamplerYcbcrConversionInfo_self(val);

    return size;
}

static inline void
vn_encode_VkSamplerYcbcrConversionInfo_pnext(struct vn_cs_encoder *enc, const void *val)
{
    /* no known/supported struct */
    vn_encode_simple_pointer(enc, NULL);
}

static inline void
vn_encode_VkSamplerYcbcrConversionInfo_self(struct vn_cs_encoder *enc, const VkSamplerYcbcrConversionInfo *val)
{
    /* skip val->{sType,pNext} */
    vn_encode_VkSamplerYcbcrConversion(enc, &val->conversion);
}

static inline void
vn_encode_VkSamplerYcbcrConversionInfo(struct vn_cs_encoder *enc, const VkSamplerYcbcrConversionInfo *val)
{
    assert(val->sType == VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO);
    vn_encode_VkStructureType(enc, &(VkStructureType){ VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO });
    vn_encode_VkSamplerYcbcrConversionInfo_pnext(enc, val->pNext);
    vn_encode_VkSamplerYcbcrConversionInfo_self(enc, val);
}

/* struct VkViewport */

static inline size_t
vn_sizeof_VkViewport(const VkViewport *val)
{
    size_t size = 0;
    size += vn_sizeof_float(&val->x);
    size += vn_sizeof_float(&val->y);
    size += vn_sizeof_float(&val->width);
    size += vn_sizeof_float(&val->height);
    size += vn_sizeof_float(&val->minDepth);
    size += vn_sizeof_float(&val->maxDepth);
    return size;
}

static inline void
vn_encode_VkViewport(struct vn_cs_encoder *enc, const VkViewport *val)
{
    vn_encode_float(enc, &val->x);
    vn_encode_float(enc, &val->y);
    vn_encode_float(enc, &val->width);
    vn_encode_float(enc, &val->height);
    vn_encode_float(enc, &val->minDepth);
    vn_encode_float(enc, &val->maxDepth);
}

static inline void
vn_decode_VkViewport(struct vn_cs_decoder *dec, VkViewport *val)
{
    vn_decode_float(dec, &val->x);
    vn_decode_float(dec, &val->y);
    vn_decode_float(dec, &val->width);
    vn_decode_float(dec, &val->height);
    vn_decode_float(dec, &val->minDepth);
    vn_decode_float(dec, &val->maxDepth);
}

/* struct VkOffset2D */

static inline size_t
vn_sizeof_VkOffset2D(const VkOffset2D *val)
{
    size_t size = 0;
    size += vn_sizeof_int32_t(&val->x);
    size += vn_sizeof_int32_t(&val->y);
    return size;
}

static inline void
vn_encode_VkOffset2D(struct vn_cs_encoder *enc, const VkOffset2D *val)
{
    vn_encode_int32_t(enc, &val->x);
    vn_encode_int32_t(enc, &val->y);
}

static inline void
vn_decode_VkOffset2D(struct vn_cs_decoder *dec, VkOffset2D *val)
{
    vn_decode_int32_t(dec, &val->x);
    vn_decode_int32_t(dec, &val->y);
}

static inline size_t
vn_sizeof_VkOffset2D_partial(const VkOffset2D *val)
{
    size_t size = 0;
    /* skip val->x */
    /* skip val->y */
    return size;
}

static inline void
vn_encode_VkOffset2D_partial(struct vn_cs_encoder *enc, const VkOffset2D *val)
{
    /* skip val->x */
    /* skip val->y */
}

/* struct VkExtent2D */

static inline size_t
vn_sizeof_VkExtent2D(const VkExtent2D *val)
{
    size_t size = 0;
    size += vn_sizeof_uint32_t(&val->width);
    size += vn_sizeof_uint32_t(&val->height);
    return size;
}

static inline void
vn_encode_VkExtent2D(struct vn_cs_encoder *enc, const VkExtent2D *val)
{
    vn_encode_uint32_t(enc, &val->width);
    vn_encode_uint32_t(enc, &val->height);
}

static inline void
vn_decode_VkExtent2D(struct vn_cs_decoder *dec, VkExtent2D *val)
{
    vn_decode_uint32_t(dec, &val->width);
    vn_decode_uint32_t(dec, &val->height);
}

static inline size_t
vn_sizeof_VkExtent2D_partial(const VkExtent2D *val)
{
    size_t size = 0;
    /* skip val->width */
    /* skip val->height */
    return size;
}

static inline void
vn_encode_VkExtent2D_partial(struct vn_cs_encoder *enc, const VkExtent2D *val)
{
    /* skip val->width */
    /* skip val->height */
}

/* struct VkRect2D */

static inline size_t
vn_sizeof_VkRect2D(const VkRect2D *val)
{
    size_t size = 0;
    size += vn_sizeof_VkOffset2D(&val->offset);
    size += vn_sizeof_VkExtent2D(&val->extent);
    return size;
}

static inline void
vn_encode_VkRect2D(struct vn_cs_encoder *enc, const VkRect2D *val)
{
    vn_encode_VkOffset2D(enc, &val->offset);
    vn_encode_VkExtent2D(enc, &val->extent);
}

static inline void
vn_decode_VkRect2D(struct vn_cs_decoder *dec, VkRect2D *val)
{
    vn_decode_VkOffset2D(dec, &val->offset);
    vn_decode_VkExtent2D(dec, &val->extent);
}

static inline size_t
vn_sizeof_VkRect2D_partial(const VkRect2D *val)
{
    size_t size = 0;
    size += vn_sizeof_VkOffset2D_partial(&val->offset);
    size += vn_sizeof_VkExtent2D_partial(&val->extent);
    return size;
}

static inline void
vn_encode_VkRect2D_partial(struct vn_cs_encoder *enc, const VkRect2D *val)
{
    vn_encode_VkOffset2D_partial(enc, &val->offset);
    vn_encode_VkExtent2D_partial(enc, &val->extent);
}

/* struct VkMemoryDedicatedRequirements chain */

static inline size_t
vn_sizeof_VkMemoryDedicatedRequirements_pnext(const void *val)
{
    /* no known/supported struct */
    return vn_sizeof_simple_pointer(NULL);
}

static inline size_t
vn_sizeof_VkMemoryDedicatedRequirements_self(const VkMemoryDedicatedRequirements *val)
{
    size_t size = 0;
    /* skip val->{sType,pNext} */
    size += vn_sizeof_VkBool32(&val->prefersDedicatedAllocation);
    size += vn_sizeof_VkBool32(&val->requiresDedicatedAllocation);
    return size;
}

static inline size_t
vn_sizeof_VkMemoryDedicatedRequirements(const VkMemoryDedicatedRequirements *val)
{
    size_t size = 0;

    size += vn_sizeof_VkStructureType(&val->sType);
    size += vn_sizeof_VkMemoryDedicatedRequirements_pnext(val->pNext);
    size += vn_sizeof_VkMemoryDedicatedRequirements_self(val);

    return size;
}

static inline void
vn_decode_VkMemoryDedicatedRequirements_pnext(struct vn_cs_decoder *dec, const void *val)
{
    /* no known/supported struct */
    if (vn_decode_simple_pointer(dec))
        assert(false);
}

static inline void
vn_decode_VkMemoryDedicatedRequirements_self(struct vn_cs_decoder *dec, VkMemoryDedicatedRequirements *val)
{
    /* skip val->{sType,pNext} */
    vn_decode_VkBool32(dec, &val->prefersDedicatedAllocation);
    vn_decode_VkBool32(dec, &val->requiresDedicatedAllocation);
}

static inline void
vn_decode_VkMemoryDedicatedRequirements(struct vn_cs_decoder *dec, VkMemoryDedicatedRequirements *val)
{
    VkStructureType stype;
    vn_decode_VkStructureType(dec, &stype);
    assert(stype == VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS);

    assert(val->sType == stype);
    vn_decode_VkMemoryDedicatedRequirements_pnext(dec, val->pNext);
    vn_decode_VkMemoryDedicatedRequirements_self(dec, val);
}

static inline size_t
vn_sizeof_VkMemoryDedicatedRequirements_pnext_partial(const void *val)
{
    /* no known/supported struct */
    return vn_sizeof_simple_pointer(NULL);
}

static inline size_t
vn_sizeof_VkMemoryDedicatedRequirements_self_partial(const VkMemoryDedicatedRequirements *val)
{
    size_t size = 0;
    /* skip val->{sType,pNext} */
    /* skip val->prefersDedicatedAllocation */
    /* skip val->requiresDedicatedAllocation */
    return size;
}

static inline size_t
vn_sizeof_VkMemoryDedicatedRequirements_partial(const VkMemoryDedicatedRequirements *val)
{
    size_t size = 0;

    size += vn_sizeof_VkStructureType(&val->sType);
    size += vn_sizeof_VkMemoryDedicatedRequirements_pnext_partial(val->pNext);
    size += vn_sizeof_VkMemoryDedicatedRequirements_self_partial(val);

    return size;
}

static inline void
vn_encode_VkMemoryDedicatedRequirements_pnext_partial(struct vn_cs_encoder *enc, const void *val)
{
    /* no known/supported struct */
    vn_encode_simple_pointer(enc, NULL);
}

static inline void
vn_encode_VkMemoryDedicatedRequirements_self_partial(struct vn_cs_encoder *enc, const VkMemoryDedicatedRequirements *val)
{
    /* skip val->{sType,pNext} */
    /* skip val->prefersDedicatedAllocation */
    /* skip val->requiresDedicatedAllocation */
}

static inline void
vn_encode_VkMemoryDedicatedRequirements_partial(struct vn_cs_encoder *enc, const VkMemoryDedicatedRequirements *val)
{
    assert(val->sType == VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS);
    vn_encode_VkStructureType(enc, &(VkStructureType){ VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS });
    vn_encode_VkMemoryDedicatedRequirements_pnext_partial(enc, val->pNext);
    vn_encode_VkMemoryDedicatedRequirements_self_partial(enc, val);
}

/* struct VkMemoryRequirements2 chain */

static inline size_t
vn_sizeof_VkMemoryRequirements2_pnext(const void *val)
{
    const VkBaseInStructure *pnext = val;
    size_t size = 0;

    while (pnext) {
        switch ((int32_t)pnext->sType) {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
            size += vn_sizeof_simple_pointer(pnext);
            size += vn_sizeof_VkStructureType(&pnext->sType);
            size += vn_sizeof_VkMemoryRequirements2_pnext(pnext->pNext);
            size += vn_sizeof_VkMemoryDedicatedRequirements_self((const VkMemoryDedicatedRequirements *)pnext);
            return size;
        default:
            /* ignore unknown/unsupported struct */
            break;
        }
        pnext = pnext->pNext;
    }

    return vn_sizeof_simple_pointer(NULL);
}

static inline size_t
vn_sizeof_VkMemoryRequirements2_self(const VkMemoryRequirements2 *val)
{
    size_t size = 0;
    /* skip val->{sType,pNext} */
    size += vn_sizeof_VkMemoryRequirements(&val->memoryRequirements);
    return size;
}

static inline size_t
vn_sizeof_VkMemoryRequirements2(const VkMemoryRequirements2 *val)
{
    size_t size = 0;

    size += vn_sizeof_VkStructureType(&val->sType);
    size += vn_sizeof_VkMemoryRequirements2_pnext(val->pNext);
    size += vn_sizeof_VkMemoryRequirements2_self(val);

    return size;
}

static inline void
vn_decode_VkMemoryRequirements2_pnext(struct vn_cs_decoder *dec, const void *val)
{
    VkBaseOutStructure *pnext = (VkBaseOutStructure *)val;
    VkStructureType stype;

    if (!vn_decode_simple_pointer(dec))
        return;

    vn_decode_VkStructureType(dec, &stype);
    while (true) {
        assert(pnext);
        if (pnext->sType == stype)
            break;
    }

    switch ((int32_t)pnext->sType) {
    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        vn_decode_VkMemoryRequirements2_pnext(dec, pnext->pNext);
        vn_decode_VkMemoryDedicatedRequirements_self(dec, (VkMemoryDedicatedRequirements *)pnext);
        break;
    default:
        assert(false);
        break;
    }
}

static inline void
vn_decode_VkMemoryRequirements2_self(struct vn_cs_decoder *dec, VkMemoryRequirements2 *val)
{
    /* skip val->{sType,pNext} */
    vn_decode_VkMemoryRequirements(dec, &val->memoryRequirements);
}

static inline void
vn_decode_VkMemoryRequirements2(struct vn_cs_decoder *dec, VkMemoryRequirements2 *val)
{
    VkStructureType stype;
    vn_decode_VkStructureType(dec, &stype);
    assert(stype == VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2);

    assert(val->sType == stype);
    vn_decode_VkMemoryRequirements2_pnext(dec, val->pNext);
    vn_decode_VkMemoryRequirements2_self(dec, val);
}

static inline size_t
vn_sizeof_VkMemoryRequirements2_pnext_partial(const void *val)
{
    const VkBaseInStructure *pnext = val;
    size_t size = 0;

    while (pnext) {
        switch ((int32_t)pnext->sType) {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
            size += vn_sizeof_simple_pointer(pnext);
            size += vn_sizeof_VkStructureType(&pnext->sType);
            size += vn_sizeof_VkMemoryRequirements2_pnext_partial(pnext->pNext);
            size += vn_sizeof_VkMemoryDedicatedRequirements_self_partial((const VkMemoryDedicatedRequirements *)pnext);
            return size;
        default:
            /* ignore unknown/unsupported struct */
            break;
        }
        pnext = pnext->pNext;
    }

    return vn_sizeof_simple_pointer(NULL);
}

static inline size_t
vn_sizeof_VkMemoryRequirements2_self_partial(const VkMemoryRequirements2 *val)
{
    size_t size = 0;
    /* skip val->{sType,pNext} */
    size += vn_sizeof_VkMemoryRequirements_partial(&val->memoryRequirements);
    return size;
}

static inline size_t
vn_sizeof_VkMemoryRequirements2_partial(const VkMemoryRequirements2 *val)
{
    size_t size = 0;

    size += vn_sizeof_VkStructureType(&val->sType);
    size += vn_sizeof_VkMemoryRequirements2_pnext_partial(val->pNext);
    size += vn_sizeof_VkMemoryRequirements2_self_partial(val);

    return size;
}

static inline void
vn_encode_VkMemoryRequirements2_pnext_partial(struct vn_cs_encoder *enc, const void *val)
{
    const VkBaseInStructure *pnext = val;

    while (pnext) {
        switch ((int32_t)pnext->sType) {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
            vn_encode_simple_pointer(enc, pnext);
            vn_encode_VkStructureType(enc, &pnext->sType);
            vn_encode_VkMemoryRequirements2_pnext_partial(enc, pnext->pNext);
            vn_encode_VkMemoryDedicatedRequirements_self_partial(enc, (const VkMemoryDedicatedRequirements *)pnext);
            return;
        default:
            /* ignore unknown/unsupported struct */
            break;
        }
        pnext = pnext->pNext;
    }

    vn_encode_simple_pointer(enc, NULL);
}

static inline void
vn_encode_VkMemoryRequirements2_self_partial(struct vn_cs_encoder *enc, const VkMemoryRequirements2 *val)
{
    /* skip val->{sType,pNext} */
    vn_encode_VkMemoryRequirements_partial(enc, &val->memoryRequirements);
}

static inline void
vn_encode_VkMemoryRequirements2_partial(struct vn_cs_encoder *enc, const VkMemoryRequirements2 *val)
{
    assert(val->sType == VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2);
    vn_encode_VkStructureType(enc, &(VkStructureType){ VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 });
    vn_encode_VkMemoryRequirements2_pnext_partial(enc, val->pNext);
    vn_encode_VkMemoryRequirements2_self_partial(enc, val);
}

#endif /* VN_PROTOCOL_DRIVER_STRUCTS_H */
