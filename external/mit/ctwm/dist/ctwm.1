'\" t
.\"     Title: ctwm
.\"    Author: [see the "AUTHORS" section]
.\" Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
.\"      Date: 04/11/2021
.\"    Manual: \ \&
.\"    Source: \ \&
.\"  Language: English
.\"
.TH "CTWM" "1" "04/11/2021" "\ \&" "\ \&"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ctwm \- Claude\*(Aqs Tab Window Manager for the X Window System
.SH "SYNTAX"
.sp
.if n \{\
.RS 4
.\}
.nf
ctwm [(\-\-display | \-d) dpy]  [\-\-replace]  [\-\-single]
     [(\-\-file | \-f) initfile]  [\-\-cfgchk]  [\-\-dumpcfg]
     [\-\-nom4 | \-n]  [(\-\-keep\-defs | \-k)]  [(\-\-keep | \-K) m4file]
     [\-\-verbose | \-v]  [\-\-quiet | \-q]  [\-\-mono]  [\-\-xrm resource]
     [\-\-version]  [\-\-info]  [\-\-nowelcome | \-W]
     [(\-\-window | \-w) [win\-id]]  [\-\-name name]
     [\-\-clientId clid]  [\-\-restore resfname]
     [\-\-help | \-h]
.fi
.if n \{\
.RE
.\}
.SH "DESCRIPTION"
.sp
ctwm is a window manager for the X Window System\&. It provides titlebars, shaped windows, virtual screens (workspaces), several forms of icon management, user\-defined macro functions, click\-to\-type and pointer\-driven keyboard focus, and user\-specified key and pointer button bindings\&. It is actually twm(1) (Tab Window Manager) from the MIT X11 distribution slightly modified to accommodate the use of several virtual screens (workspaces)\&. It is heavily inspired by the Hewlett\-Packard vuewm window manager\&. In addition, ctwm can use coloured, shaped icons and background root pixmaps in XPM format [from Arnaud Le Hors], in JPEG using libjpeg, and xwd files\&. ctwm can be compiled to use any combination of the above icon/pixmap formats\&.
.sp
This program is usually started by the user\(cqs session manager or startup script\&. When used from xdm(1) or xinit(1) without a session manager, ctwm is frequently executed in the foreground as the last client\&. When run this way, exiting ctwm causes the session to be terminated (i\&.e\&. logged out)\&.
.sp
By default, application windows are surrounded by a \(lqframe\(rq with a titlebar at the top and a special border around the window\&. The titlebar contains the window\(cqs name, a rectangle that is lit when the window is receiving keyboard input, and function boxes known as \(lqtitlebuttons\(rq at the left and right edges of the titlebar to which actions can be bound\&.
.sp
Pressing pointer Button1 (usually the left\-most button unless it has been changed with xmodmap) on a titlebutton will invoke the function associated with the button\&. In the default interface, windows are iconified by clicking (pressing and then immediately releasing) the left titlebutton (which looks like a Dot)\&. Conversely, windows are deiconified by clicking in the associated icon or entry in the icon manager (see description of the variable ShowIconManager and of the function f\&.showiconmgr)\&.
.sp
Windows are resized by pressing the right titlebutton (which resembles a group of nested squares), dragging the pointer over edge that is to be moved, and releasing the pointer when the outline of the window is the desired size\&. Similarly, windows are moved by pressing in the title or highlight region, dragging a window outline to the new location, and then releasing when the outline is in the desired position\&. Just clicking in the title or highlight region raises the window without moving it\&.
.sp
When new windows are created, ctwm will honor any size and location information requested by the user (usually through \-geometry command line argument or resources for the individual applications)\&. Otherwise, an outline of the window\(cqs default size, its titlebar, and lines dividing the window into a 3x3 grid that track the pointer are displayed\&. Clicking pointer Button1 will position the window at the current position and give it the default size\&. Pressing pointer Button2 (usually the middle pointer button) and dragging the outline will give the window its current position but allow the sides to be resized as described above\&. Clicking pointer Button3 (usually the right pointer button) will give the window its current position but attempt to make it long enough to touch the bottom the screen\&.
.SH "OPTIONS"
.sp
ctwm accepts the following command line options:
.PP
\-\-help, \-h
.RS 4
Print usage text\&.
.RE
.PP
\-\-display=dpy, \-d dpy
.RS 4
This option specifies the X server to use\&.
.RE
.PP
\-\-replace
.RS 4
This option indicates that it is not an error if a window manager is already running\&. In that case, the existing window manager is asked to quit, and ctwm takes its place\&. Available only if ctwm is built with the
USE_EWMH
flag\&. First appeared in 4\&.0\&.0\&.
.RE
.PP
\-\-single
.RS 4
This option indicates that only the default screen (as specified by
\-\-display
or by the
DISPLAY
environment variable) should be managed\&. By default, ctwm will attempt to manage all screens on the display\&.
.RE
.PP
\-\-cfgchk
.RS 4
This option causes ctwm to only try to parse the config file, and indicate whether errors are found\&.
.RE
.PP
\-\-dumpcfg
.RS 4
This option causes ctwm to print out the compiled\-in fallback config\&. First appeared in 4\&.0\&.0\&.
.RE
.PP
\-\-file=filename, \-f filename
.RS 4
This option specifies the name of the startup file to use\&. ctwm will first try to load filename\&.num, where
num
is the screen number\&. If it fails, it will try to load filename\&. By default, ctwm will look in the user\(cqs home directory for files named
\&.ctwmrc\&.num,
\&.ctwmrc,
\&.twmrc\&.num, or
\&.twmrc
(where
num
is a screen number)\&.
.RE
.PP
\-\-verbose, \-v
.RS 4
This option indicates that ctwm should print error messages whenever an unexpected X Error event is received\&. This can be useful when debugging applications but can be distracting in regular use\&.
.RE
.PP
\-\-quiet, \-q
.RS 4
Disables
\-\-verbose
(useful for overriding aliases, etc)\&.
.RE
.PP
\-\-nom4, \-n
.RS 4
This option indicates that ctwm should not filter the startup file through
m4\&. Available only if ctwm is built with the
USE_M4
flag\&.
.RE
.PP
\-\-keep\-defs, \-k
.RS 4
This option indicates that ctwm should keep the definitions it prepends to your startup file when filtering through
m4
in /tmp\&. Available only if ctwm is built with the
USE_M4
flag\&.
.RE
.PP
\-\-keep=m4file, \-K m4file
.RS 4
This option indicates that ctwm should keep the result of filtering your startup file through
m4
in the named file\&. Available only if ctwm is built with the
USE_M4
flag\&.
.RE
.PP
\-\-mono
.RS 4
Run in monochrome mode\&.
.RE
.PP
\-\-version
.RS 4
ctwm just prints its version number\&.
.RE
.PP
\-\-info
.RS 4
ctwm prints its detailed version and compile time options\&.
.RE
.PP
\-\-window[=win\-id], \-w[win\-id]
.RS 4
If
\-w
is specified without a win\-id value, ctwm does not take over the whole screen(s); instead it creates a new window that becomes its root window\&. If the win\-id value is given, it is considered to be the id of an existing window, in which case, ctwm will try to use this window as root window\&. You can run any number of instantiations of ctwm at the same time\&. You can even have embedded ctwm instantiations\&. This is totally useless, but I like it\&. The f\&.adoptwindow function can be used to capture an existing window belonging to another ctwm\&. A possible use of such mode can be to test new configuration file without restarting ctwm\&.
.RE
.PP
\-\-name=name, \-n name
.RS 4
Set the captivename when using
\-\-window\&.
.RE
.PP
\-\-nowelcome, \-W
.RS 4
This option tells ctwm not to display any welcome when starting\&.
.RE
.PP
\-\-clientId=clid, \-\-restore=resfname
.RS 4
Something to do with session management
.RE
.PP
\-\-xrm=resource
.RS 4
Ignored\&.
.RE
.sp
ctwm uses getopt_long() for parsing the command\-line options\&. This means that args can be passed via \-\-long=arg and \-\-long arg, as well as \-l arg and \-larg, and short args can be bundled like \-vnk as well as \-v \-n \-k\&.
.sp
Note, however, that the handling of optional args is slightly different; they \fBmust\fR be specified with = or no space\&. e\&.g\&., \-\-window=123 will set the win\-id to 123, but \-\-window 123 will not; the 123 will be treated as a separate argument\&. Similarly, it must be set as \-w123, not \-w 123\&.
.SH "CUSTOMIZATION"
.sp
Much of ctwm\(cqs appearance and behavior can be controlled by providing a startup file in one of the following locations (searched in order for each screen being managed when ctwm begins):
.PP
$HOME/\&.ctwmrc\&.screennumber
.RS 4
The
screennumber
is a small positive number (e\&.g\&. 0, 1, etc\&.) representing the screen number (e\&.g\&. the last number in the DISPLAY environment variable
host:displaynum\&.screennum) that would be used to contact that screen of the display\&. This is intended for displays with multiple screens of differing visual types\&.
.RE
.PP
$HOME/\&.ctwmrc
.RS 4
This is the usual name for an individual user\(cqs startup file\&.
.RE
.PP
$HOME/\&.twmrc\&.screennumber, $HOME/\&.twmrc
.RS 4
The users twm startup file\&.
.RE
.PP
/etc/X11/ctwm/system\&.ctwmrc
.RS 4
If none of the preceding files are found, ctwm will look in this file for a default configuration\&. This is often tailored by the site administrator to provide convenient menus or familiar bindings for novice users\&.
.RE
.sp
If no startup files are found, ctwm will use the built\-in defaults described above\&. The only resource used by ctwm is bitmapFilePath for a colon\-separated list of directories to search when looking for bitmap files (for more information, see the Athena Widgets manual and xrdb(1))\&.
.sp
ctwm startup files are logically broken up into three types of specifications: Variables, Bindings, Menus\&. The Variables section must come first and is used to describe the fonts, colors, cursors, border widths, icon and window placement, highlighting, autoraising, layout of titles, warping, use of the icon manager\&. The Bindings section usually comes second and is used to specify the functions that should be invoked when keyboard and pointer buttons are pressed in windows, icons, titles, and frames\&. The Menus section gives any user\-defined menus (containing functions to be invoked or commands to be executed)\&.
.sp
Variable names and keywords are case\-insensitive\&. Strings must be surrounded by double quote characters (e\&.g\&. \(lqblue\(rq) and are case\-sensitive\&. A pound sign (#) outside of a string causes the remainder of the line in which the character appears to be treated as a comment\&.
.SH "M4 PREPROCESSING"
.sp
ctwm can use m4(1) to pre\-process its setup files\&. The availability of the m4 preprocessing is dependent on the build option USE_M4 (on by default), and can be selectively disabled with the \-\-nom4 command\-line argument\&.
.sp
When ctwm starts up, it opens a file for input as described above\&. But, it processes that file through m4 before parsing it\&. So, you can use m4 macros to perform operations at runtime\&. This makes it very easy to work when you use many different displays, with different characteristics\&. For example, If you want to set the lower right section of the screen to be your IconRegion, (see below for details on the IconRegion variable) you can use m4 directives and pre\-defined symbols to calculate the region you want\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
define(IRegion, translit(eval(WIDTH/3)*eval(HEIGHT/2)+eval(WIDTH\-WIDTH/3)\-0, *, x))
IconRegion  "IRegion" SOUTH EAST 75 25
.fi
.if n \{\
.RE
.\}
.sp
will define the lower half, and right\-hand third of the screen\&. The above makes use of symbols that are predefined for m4 by ctwm\&. The symbols WIDTH and HEIGHT are among those calculated by ctwm and written into a temporary file for m4 to use\&.
.sp
You may well find that if you research the m4(1) manual well, and understand the power of m4, this will be a \fIvery\fR useful and powerful tool\&. But, if you use any of the symbols which are predefined by m4, you are in severe danger! For example, the Sun m4 predefines shift, so if you use that name in your \&.ctwmrc, you are out of luck\&.
.sp
The following symbols are predefined by ctwm:
.SS "Hostnames"
.PP
SERVERHOST
.RS 4
This variable is set to the name of the machine that is running the X server\&.
.RE
.PP
CLIENTHOST
.RS 4
The machine that is running the clients\&. (ie, ctwm)
.RE
.PP
HOSTNAME
.RS 4
As of 4\&.0\&.2, this is a duplicate of
CLIENTHOST\&. In prior versions,
gethostbyname()
was used to attempt to derive a canonical or fully\-qualified version of the hostname\&.
.RE
.SS "User Info"
.PP
USER
.RS 4
The name of the user running the program\&. Value taken from environmental variables
$USER
and
$LOGNAME, or from the passwd lookup for your uid if they don\(cqt exist\&. Falls back to \(lqunknown\(rq if all methods fail\&.
.RE
.PP
HOME
.RS 4
The user\(cqs home directory\&. Gotten from the environment var
$HOME\&.
.RE
.SS "ctwm info"
.PP
TWM_TYPE
.RS 4
Tells which
twm
offshoot is running\&. It will always be set to the string \(lqctwm\(rq in this program\&. This is useful for protecting parts of your
\&.twmrc
file that twm proper won\(cqt understand (like
WorkSpaces) so that it is still usable with other
twm
programs\&.
.RE
.PP
TWM_VERSION
.RS 4
Tells which ctwm version is running in the form of a floating point number\&.
.RE
.PP
CTWM_VERSION_MAJOR, CTWM_VERSION_MINOR, CTWM_VERSION_PATCH, CTWM_VERSION_ADDL
.RS 4
Gives the ctwm version split out\&. e\&.g\&., for a version like "3\&.8\&.2\-beta1", the
_MAJOR
will be "3",
_MINOR
"8",
_PATCH
"2", and
_ADDL
"\-beta1"\&. Final releases will generally have an empty
CTWM_VERSION_ADDL; it\(cqs mostly meaningful in dev and betas\&. For comparison, in this situation, TWM_VERSION will be "3\&.8\&.2"\&.
.sp
The
CTWM_VERSION_*
variables first appeared in 4\&.0\&.0\&.
.RE
.SS "X server info"
.PP
VERSION
.RS 4
The X major protocol version\&. As seen by ProtocolVersion(3)\&.
.RE
.PP
REVISION
.RS 4
The X minor protocol revision\&. As seen by ProtocolRevision(3)\&.
.RE
.PP
VENDOR
.RS 4
The vendor of your X server\&. For example:
MIT X Consortium\&.
.RE
.PP
RELEASE
.RS 4
The release number of your X server\&. For MIT X11R5, this is
5\&.
.RE
.SS "Display info"
.PP
WIDTH
.RS 4
The width of your display in pixels\&.
.RE
.PP
HEIGHT
.RS 4
The height of your display in pixels\&.
.RE
.PP
X_RESOLUTION
.RS 4
The X resolution of your display in pixels per meter\&.
.RE
.PP
Y_RESOLUTION
.RS 4
The Y resolution of your display in pixels per meter\&.
.RE
.PP
PLANES
.RS 4
The number of bit planes your display supports in the default root window\&.
.RE
.PP
BITS_PER_RGB
.RS 4
The number of significant bits in an RGB color\&. (log base 2 of the number of distinct colors that can be created\&. This is often different from the number of colors that can be displayed at once\&.)
.RE
.PP
CLASS
.RS 4
Your visual class\&. Will return one of
StaticGray,
GrayScale,
StaticColor,
PseudoColor,
TrueColor,
DirectColor, or, if it cannot determine what you have,
NonStandard\&.
.RE
.PP
COLOR
.RS 4
This will be either \(lqYes\(rq or \(lqNo\(rq\&. This is just a wrapper around the above definition\&. Returns \(lqYes\(rq on
*Color, and \(lqNo\(rq on
StaticGray
and
GrayScale\&.
.RE
.SS "ctwm compile\-time options"
.PP
XPM
.RS 4
Is defined only if ctwm was compiled with XPM support\&.
.RE
.PP
PIXMAP_DIRECTORY
.RS 4
The directory where the ctwm pictures are installed\&.
.RE
.PP
JPEG
.RS 4
Is defined only if ctwm was compiled with JPEG support\&.
.RE
.PP
SOUNDS
.RS 4
Is defined only if ctwm was compiled with SOUND support\&.
.RE
.PP
EWMH
.RS 4
Is defined only if ctwm was compiled with EWMH support\&. First appeared in 4\&.0\&.0\&.
.RE
.PP
I18N
.RS 4
Is defined if ctwm was compiled with I18N support\&. This is no longer optional since 3\&.8 and is always compiled in\&. The definition will be removed in a future version\&.
.RE
.SS "ctwm run\-time options"
.PP
TWM_CAPTIVE
.RS 4
This will be either \(lqYes\(rq or \(lqNo\(rq\&. \(lqYes\(rq if the current ctwm is captive (flag \-w), \(lqNo\(rq in the other case\&.
.RE
.PP
TWM_CAPTIVE_NAME
.RS 4
Defined only if TWM_CAPTIVE is also defined\&. Contains the name of the captive ctwm (flag \-\-name)\&.
.RE
.SS "Obsolete options"
.PP
GNOME
.RS 4
Defined when ctwm was compiled with GNOME1 support\&. Removed after 3\&.8\&.2\&.
.RE
.SH "VARIABLES"
.sp
Many of the aspects of ctwm\(cqs user interface are controlled by variables that may be set in the user\(cqs startup file\&. Some of the options are enabled or disabled simply by the presence of a particular keyword\&. Other options require keywords, numbers, strings, or lists of all of these\&.
.sp
Lists are surrounded by braces and are usually separated by whitespace or a newline\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
AutoRaise { "emacs" "XTerm" "Xmh" }
.fi
.if n \{\
.RE
.\}
.sp
or
.sp
.if n \{\
.RS 4
.\}
.nf
AutoRaise
{
    "emacs"
    "XTerm"
    "Xmh"
}
.fi
.if n \{\
.RE
.\}
.sp
When a variable containing a list of strings representing windows is searched (e\&.g\&. to determine whether or not to enable autoraise as shown above), a string must be an exact, case\-sensitive match to the window\(cqs name (given by various window properties, such as WM_NAME), resource name or class name (both given by the WM_CLASS window property)\&. The preceding example would enable autoraise on windows named \(lqemacs\(rq as well as any xterm (since they are of class \(lqXTerm\(rq) or xmh windows (which are of class \(lqXmh\(rq)\&.
.sp
String arguments that are interpreted as filenames (see the Pixmaps, Cursors, and IconDirectory below) will prepend the user\(cqs directory (specified by the HOME environment variable) if the first character is a tilde (~)\&. If, instead, the first character is a colon (:), the name is assumed to refer to one of the internal bitmaps that are used to create the default titlebars symbols: :xlogo or :iconify (both refer to the X used for the iconify button), :resize (the nested squares used by the resize button), and :question (the question mark used for non\-existent bitmap files)\&.
.sp
The following variables may be specified at the top of a ctwm startup file\&. Lists of window name prefix strings are indicated by win\-list\&. Optional arguments are shown in square brackets:
.PP
AlwaysOnTop { win\-list }
.RS 4
This variable specifies a list of windows (all windows if the list is defaulted) that ctwm will try its best to maintain on top of others\&. This doesn\(cqt work in all case\&.
.RE
.PP
AlwaysShowWindowWhenMovingFromWorkspaceManager
.RS 4
When
ReallyMoveInWorkspaceManager
is present and the user is moving a window from the WorkSpaceMap, ctwm display the actual window only if it crosses the current active workspace\&. If
AlwaysShowWindowWhenMovingFromWorkspaceManager
is present, the actual window is always visible during the move, regardless of whether it crosses the current workspace or not\&. The Shift key toggles this behaviour\&.
.RE
.PP
AlwaysSqueezeToGravity [{ win\-list }]
.RS 4
This variable indicates that ctwm should obey window gravity when squeezing a window even when the window has a titlebar\&. Normally, ctwm will always squeeze a window that has a titlebar toward the north\&. The optional
win\-list
may be used to control which windows this applies on\&.
.RE
.PP
AnimationSpeed speed
.RS 4
The
speed
argument is a non\-negative integer\&. It determines the number of times a second animations (if any) are updated\&. If
speed
is 0, animations are freezed\&. The default value is 0\&.
.RE
.PP
AutoFocusToTransients
.RS 4
Transient windows get focus automatically when created\&. Useful with programs that have keyboard shortcuts that pop up windows\&.
.RE
.PP
AutoLower [{ win\-list }]
.RS 4
This variable specifies a list of windows (all windows if the list is defaulted) to be automatically lowered whenever the pointer leaves a window\&. This action can be interactively enabled or disabled on individual windows using the function
f\&.autolower\&.
.RE
.PP
AutoOccupy
.RS 4
This variable specifies that clients will automatically change their occupation when their name or icon name changes\&. The new occupation will be recalculated from the Occupy and OccupyAll fields in the
\&.ctwmrc
file\&.
.RE
.PP
AutoPopup [{ win\-list }]
.RS 4
This variables specifies a list of windows which will be deiconified whenever their name changes\&. Can be used for xconsole, for instance,which adds a "*" to its name whenever something gets displayed on the console, or for various mail readers who change their icons depending on the presence of unread mail\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
AutoPriority
.RS 4
This variable specifies that ctwm should automatically recompute the priority of a window (and its associated icon) when its name changes\&. See also
OnTopPriority\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
AutoRaise [{ win\-list }]
.RS 4
This variable specifies a list of windows (all windows if the list is defaulted) to be automatically raised whenever the pointer has come to rest in a window for the amount of time specified by the
RaiseDelay
variable\&. This action can be interactively enabled or disabled on individual windows using the function
f\&.autoraise\&.
.RE
.PP
AutoRaiseIcons
.RS 4
Icons are raised when the cursor enters it\&. Useful with ShrinkIconTitles\&.
.RE
.PP
AutoRelativeResize
.RS 4
This variable indicates that dragging out a window size (either when initially sizing the window with pointer Button2 or when resizing it) should not wait until the pointer has crossed the window edges\&. Instead, moving the pointer automatically causes the nearest edge or edges to move by the same amount\&. This allows the resizing of windows that extend off the edge of the screen\&. If the pointer is in the center of the window, or if the resize is begun by pressing a titlebutton, ctwm will still wait for the pointer to cross a window edge (to prevent accidents)\&. This option is particularly useful for people who like the press\-drag\-release method of sweeping out window sizes\&.
.RE
.PP
AutoSqueeze { win\-list }
.RS 4
These windows will be auto\-squeezed (see f\&.squeeze)\&. i\&.e\&. automatically unsqueezed when they get focus, and squeezed when they loose it\&. Useful for the workspace manager\&. Not authorized for icon managers\&.
.RE
.PP
BackingStore
.RS 4
Enable usage of backing store on menus and workspace map windows\&. See also
NoBackingStore\&. Added in 4\&.0\&.0; in previous versions this was the default\&.
.RE
.PP
BeNiceToColormap
.RS 4
By defaults new colors are allocated for shadows when a 3D look is used, but when you specify
BeNiceToColormap
ctwm uses stipling instead of new colors, the effect is less beautiful, but acceptable\&. In this case ClearShadowContrast and DarkShadowContrast have no effects\&.
.RE
.PP
BorderBottom pixels
.RS 4
This variable specifies the width in pixels of a forbidden zone at the bottom of the screen\&. All constrained window functions (f\&.movepack, f\&.move with DontMoveOff, etc\&...) will consider this zone as offscreen\&. Default is 0\&.
.RE
.PP
BorderColor string [{ wincolorlist }]
.RS 4
This variable specifies the default color of the border to be placed around all non\-iconified windows, and may only be given within a
Color
or
Monochrome
list\&. The optional
wincolorlist
specifies a list of window and color name pairs for specifying particular border colors for different types of windows\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
BorderColor "gray50"
{
    "XTerm" "red"
    "xmh"   "green"
}
.fi
.if n \{\
.RE
.\}
.sp
The default is \(lqblack\(rq\&.
.RE
.PP
BorderLeft pixels
.RS 4
This variable specifies the width in pixels of a forbidden zone at the left of the screen\&. All constrained window functions (f\&.movepack, f\&.move with DontMoveOff, etc\&...) will consider this zone as offscreen\&. Default is 0\&.
.RE
.PP
BorderResizeCursors
.RS 4
This variable specifies that ctwm should use resizing cursors when the pointer is on the window border\&. To be used preferably when you have bound a button to f\&.resize in the frame context\&.
.RE
.PP
BorderRight pixels
.RS 4
This variable specifies the width in pixels of a forbidden zone at the right of the screen\&. All constrained window functions (f\&.movepack, f\&.move with DontMoveOff, etc\&...) will consider this zone as offscreen\&. Default is 0\&.
.RE
.PP
BorderShadowDepth pixels
.RS 4
This variable specifies the depth of the shadow ctwm uses for 3D window borders, when UseThreeDBorders is selected\&.
.RE
.PP
BorderTileBackground string [{ wincolorlist }]
.RS 4
This variable specifies the default background color in the gray pattern used in unhighlighted borders (only if
NoHighlight
hasn\(cqt been set), and may only be given within a
Color
or
Monochrome
list\&. The optional
wincolorlist
allows per\-window colors to be specified\&. The default is \(lqwhite\(rq\&.
.RE
.PP
BorderTileForeground string [{ wincolorlist }]
.RS 4
This variable specifies the default foreground color in the gray pattern used in unhighlighted borders (only if
NoHighlight
hasn\(cqt been set), and may only be given within a
Color
or
Monochrome
list\&. The optional
wincolorlist
allows per\-window colors to be specified\&. The default is \(lqblack\(rq\&.
.RE
.PP
BorderTop pixels
.RS 4
This variable specifies the width in pixels of a forbidden zone at the top of the screen\&. All constrained window functions (f\&.movepack, f\&.move with DontMoveOff, etc\&...) will consider this zone as offscreen\&. Default is 0\&.
.RE
.PP
BorderWidth pixels
.RS 4
This variable specifies the width in pixels of the border surrounding all client window frames if
ClientBorderWidth
has not been specified\&. This value is also used to set the border size of windows created by ctwm (such as the icon manager)\&. The default is 2\&.
.RE
.PP
ButtonIndent pixels
.RS 4
This variable specifies the amount by which titlebuttons should be indented on all sides\&. Positive values cause the buttons to be smaller than the window text and highlight area so that they stand out\&. Setting this and the
TitleButtonBorderWidth
variables to 0 makes titlebuttons be as tall and wide as possible\&. The default is 1 if
UseThreeDTitles
is not set, 0 if it is set\&.
.RE
.PP
CenterFeedbackWindow
.RS 4
The moving and resizing information window is centered in the middle of the screen instead of the top left corner\&.
.RE
.PP
ClearShadowContrast contrast
.RS 4
Indicates to ctwm how to calculate the clear shadow color for 3D items\&. The value is a comprised between 0 and 100\&. The formula used is :
.sp
.if n \{\
.RS 4
.\}
.nf
    clear\&.{RGB} = (65535 \- color\&.{RGB}) * (contrast / 100)\&.
.fi
.if n \{\
.RE
.\}
.sp
Has no effect if
BeNiceToColormap
is active\&.
.RE
.PP
ClickToFocus
.RS 4
Focus windows by clicking on them, rather than merely mousing over them\&.
.RE
.PP
ClientBorderWidth
.RS 4
This variable indicates that border width of a window\(cqs frame should be set to the initial border width of the window, rather than to the value of
BorderWidth\&. If
Use3DBorders
is set this variable is automatically unset\&.
.RE
.PP
Color { colors\-list }
.RS 4
This variable specifies a list of color assignments to be made if the default display is capable of displaying more than simple black and white\&. The
colors\-list
is made up of the following color variables and their values:
DefaultBackground,
DefaultForeground,
MenuBackground,
MenuForeground,
MenuTitleBackground,
MenuTitleForeground, and
MenuShadowColor\&. The following color variables may also be given a list of window and color name pairs to allow per\-window colors to be specified (see
BorderColor
for details):
BorderColor,
IconManagerHighlight,
BorderTileBackground,
BorderTileForeground,
TitleBackground,
TitleForeground,
IconBackground,
IconForeground,
IconBorderColor,
IconManagerBackground, and
IconManagerForeground\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
Color
{
    MenuBackground      "gray50"
    MenuForeground      "blue"
    BorderColor         "red"    { "XTerm" "yellow" }
    TitleForeground     "yellow"
    TitleBackground     "blue"
}
.fi
.if n \{\
.RE
.\}
.sp
All of these color variables may also be specified for the
Monochrome
variable, allowing the same initialization file to be used on both color and monochrome displays\&.
.RE
.PP
ConstrainedMoveTime milliseconds
.RS 4
This variable specifies the length of time between button clicks needed to begin a constrained move operation\&. Double clicking within this amount of time when invoking
f\&.move
or other similar moving functions will cause the window only be moved in a horizontal or vertical direction\&. Setting this value to 0 will disable constrained moves\&. The default is 400 milliseconds\&.
.sp
Note that this also affects double clicking in
f\&.raiseorsqueeze, and potentially other places that need to track double clicks\&. It should probably be renamed\&.
.RE
.PP
Cursors { cursor\-list }
.RS 4
This variable specifies the glyphs that ctwm should use for various pointer cursors\&. Each cursor may be defined either from the
cursor
font or from two bitmap files\&. Shapes from the
cursor
font may be specified directly as:
.sp
.if n \{\
.RS 4
.\}
.nf
    cursorname "string"
.fi
.if n \{\
.RE
.\}
.sp
where
cursorname
is one of the cursor names listed below, and
string
is the name of a glyph as found in the file <X11/cursorfont\&.h> (without the \(lqXC_\(rq prefix)\&. If the cursor is to be defined from bitmap files, the following syntax is used instead:
.sp
.if n \{\
.RS 4
.\}
.nf
    cursorname "image" "mask"
.fi
.if n \{\
.RE
.\}
.sp
The
image
and
mask
strings specify the names of files containing the glyph image and mask in
bitmap(1)
form\&. The bitmap files are located in the same manner as icon bitmap files\&. The following example shows the default cursor definitions:
.sp
.if n \{\
.RS 4
.\}
.nf
Cursors
{
    Frame       "top_left_arrow"
    Title       "top_left_arrow"
    Icon        "top_left_arrow"
    IconMgr     "top_left_arrow"
    Move        "fleur"
    Resize      "fleur"
    Menu        "sb_left_arrow"
    Button      "hand2"
    Wait        "watch"
    Select      "dot"
    Destroy     "pirate"
}
.fi
.if n \{\
.RE
.\}
.RE
.PP
DarkShadowContrast contrast
.RS 4
Indicates to ctwm how to calculate the dark shadow color for 3D items\&. The value is a comprised between 0 and 100\&. The formula used is :
.sp
.if n \{\
.RS 4
.\}
.nf
    dark\&.{RGB}  = color\&.{RGB} * ((100 \- contrast) / 100),
.fi
.if n \{\
.RE
.\}
.sp
Has no effect if
BeNiceToColormap
is active\&.
.RE
.PP
DecorateTransients
.RS 4
This variable indicates that transient windows (those containing a
WM_TRANSIENT_FOR
property) should have titlebars\&. As of 4\&.0\&.0 this is the default\&.
.RE
.PP
DefaultBackground string
.RS 4
This variable specifies the background color to be used for sizing and information windows\&. The default is \(lqwhite\(rq\&.
.RE
.PP
DefaultForeground string
.RS 4
This variable specifies the foreground color to be used for sizing and information windows\&. The default is \(lqblack\(rq\&.
.RE
.PP
DontIconifyByUnmapping { win\-list }
.RS 4
This variable specifies a list of windows that should not be iconified by simply unmapping the window (as would be the case if
IconifyByUnmapping
had been set)\&. This is frequently used to force some windows to be treated as icons while other windows are handled by the icon manager\&.
.RE
.PP
DontMoveOff
.RS 4
This variable indicates that windows should not be allowed to be moved off the screen\&. It can be overridden by the
f\&.forcemove
function\&.
.RE
.PP
DontNameDecorations
.RS 4
Disable setting
WM_NAME
properties on the various decoration windows ctwm puts around the windows it manages\&. These are handy to keep track of what\(cqs what when poking through the list of windows on the screen, but can confuse some tools that don\(cqt expect to find them there (xwit is known to be one of them)\&. First appeared in 4\&.0\&.2\&.
.RE
.PP
DontPaintRootWindow
.RS 4
This variable tells ctwm not to paint the root window, whatever you told in the Workspaces specification\&. This is useful to have pixmaps in the Workspace Map but not on the root window\&.
.RE
.PP
DontSave { win\-list }
.RS 4
These windows won\(cqt have their characteristics saved for the session manager\&.
.RE
.PP
DontSetInactive { win\-list }
.RS 4
These windows won\(cqt be set to InactiveState when they become invisible due to a change workspace\&. This has been added because some ill\-behaved clients (Frame5) don\(cqt like this\&.
.RE
.PP
DontShowWelcomeWindow
.RS 4
Indicates the same as the
\-W
option: the welcome window is not shown\&.
.RE
.PP
DontSqueezeTitle [{ win\-list }]
.RS 4
This variable indicates that titlebars should not be squeezed to their minimum size as described under
SqueezeTitle
below\&. If the optional window list is supplied, only those windows will be prevented from being squeezed\&.
.RE
.PP
DontToggleWorkSpaceManagerState
.RS 4
Turns off the feature toggling the workspace manager state to/from map/button state when you press ctrl and the workspace manager window is in focus\&.
.RE
.PP
DontWarpCursorInWMap
.RS 4
Tells ctwm not to warp the cursor to the corresponding actual window when you click in a small window in the workspace map\&.
.RE
.PP
EWMHIgnore { message\-types }
.RS 4
Sets EWMH message types that ctwm will ignore\&. This is only valid if built with
USE_EWMH
(currently on by default)\&. The following example shows all the valid options:
.sp
.if n \{\
.RS 4
.\}
.nf
EWMHIgnore
{
    # Window states
    "STATE_MAXIMIZED_VERT"
    "STATE_MAXIMIZED_HORZ"
    "STATE_FULLSCREEN"
    "STATE_SHADED"
    "STATE_ABOVE"
    "STATE_BELOW"
}
.fi
.if n \{\
.RE
.\}
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
ForceFocus [{ win\-list }]
.RS 4
Give focus to windows whether they asked for it or not\&. This may occasionally be useful with windows that tell us not to give them focus, but still need it and fail to work right without us doing so\&. The optional window list allows specifying which windows will get such treatment\&.
.sp
First appeared in 4\&.0\&.0\&. In prior versions, a variant of this functionality was unconditionally enabled\&.
.RE
.PP
ForceIcons
.RS 4
This variable indicates that icon pixmaps specified in the
Icons
variable should override any client\-supplied pixmaps\&.
.RE
.PP
FramePadding pixels
.RS 4
This variable specifies the distance between the titlebar decorations (the button and text) and the window frame\&. The default is 2 pixels if
UseThreeDTitles
is not set, 0 if it is set\&.
.RE
.PP
GrabServer
.RS 4
Specifies that ctwm should grab the X server (blocking all events other than ours) when popping up menus and moving opaque windows\&. See also
NoGrabServer\&. Added in 4\&.0\&.0; in previous versions this was the default\&.
.RE
.PP
IconBackground string [{ win\-list }]
.RS 4
This variable specifies the background color of icons, and may only be specified inside of a
Color
or
Monochrome
list\&. The optional
win\-list
is a list of window names and colors so that per\-window colors may be specified\&. See the
BorderColor
variable for a complete description of the
win\-list\&. The default is \(lqwhite\(rq\&.
.RE
.PP
IconBorderColor string [{ win\-list }]
.RS 4
This variable specifies the color of the border used for icon windows, and may only be specified inside of a
Color
or
Monochrome
list\&. The optional
win\-list
is a list of window names and colors so that per\-window colors may be specified\&. See the
BorderColor
variable for a complete description of the
win\-list\&. The default is \(lqblack\(rq\&.
.RE
.PP
IconBorderWidth pixels
.RS 4
This variable specifies the width in pixels of the border surrounding icon windows\&. The default is 2\&.
.RE
.PP
IconDirectory string
.RS 4
This variable specifies the directory that should be searched if a bitmap file cannot be found in any of the directories in the
bitmapFilePath
resource\&.
.RE
.PP
IconFont string
.RS 4
This variable specifies the font to be used to display icon names within icons\&. The default is \(lqvariable\(rq\&.
.RE
.PP
IconForeground string [{ win\-list }]
.RS 4
This variable specifies the foreground color to be used when displaying icons, and may only be specified inside of a
Color
or
Monochrome
list\&. The optional
win\-list
is a list of window names and colors so that per\-window colors may be specified\&. See the
BorderColor
variable for a complete description of the
win\-list\&. The default is \(lqblack\(rq\&.
.RE
.PP
IconifyByUnmapping [{ win\-list }]
.RS 4
This variable indicates that windows should be iconified by being unmapped without trying to map any icons\&. This assumes that the user is will remap the window through the icon manager, the
f\&.warpto
function, or the
TwmWindows
menu\&. If the optional
win\-list
is provided, only those windows will be iconified by simply unmapping\&. Windows that have both this and the
IconManagerDontShow
options set may not be accessible if no binding to the
TwmWindows
menu is set in the user\(cqs startup file\&.
.RE
.PP
IconifyStyle string
.RS 4
Where string is either
"normal",
"mosaic",
"zoomin",
"zoomout"
or
"sweep"\&. Tells ctwm to use some fancy graphical effects when iconifying windows\&.
.RE
.PP
IconJustification string
.RS 4
Where string is either
"left",
"center"
or
"right"\&. Tells ctwm how to justify the icon image against the icon title (if any)\&.
.RE
.PP
IconManagerBackground string [{ win\-list }]
.RS 4
This variable specifies the background color to use for icon manager entries, and may only be specified inside of a
Color
or
Monochrome
list\&. The optional
win\-list
is a list of window names and colors so that per\-window colors may be specified\&. See the
BorderColor
variable for a complete description of the
win\-list\&. The default is \(lqwhite\(rq\&.
.RE
.PP
IconManagerDontShow [{ win\-list }]
.RS 4
This variable indicates that the icon manager should not display any windows\&. If the optional
win\-list
is given, only those windows will not be displayed\&. This variable is used to prevent windows that are rarely iconified (such as
xclock
or
xload) from taking up space in the icon manager\&.
.RE
.PP
IconManagerFont string
.RS 4
This variable specifies the font to be used when displaying icon manager entries\&. The default is \(lqvariable\(rq\&.
.RE
.PP
IconManagerForeground string [{ win\-list }]
.RS 4
This variable specifies the foreground color to be used when displaying icon manager entries, and may only be specified inside of a
Color
or
Monochrome
list\&. The optional
win\-list
is a list of window names and colors so that per\-window colors may be specified\&. See the
BorderColor
variable for a complete description of the
win\-list\&. The default is \(lqblack\(rq\&.
.RE
.PP
IconManagerGeometry string [ columns ]
.RS 4
This variable specifies the geometry of the icon manager window\&. The
string
argument is standard geometry specification that indicates the initial full size of the icon manager\&. The icon manager window is then broken into
columns
pieces and scaled according to the number of entries in the icon manager\&. Extra entries are wrapped to form additional rows\&. The default number of columns is 1\&.
.RE
.PP
IconManagerHighlight string [{ win\-list }]
.RS 4
This variable specifies the border color to be used when highlighting the icon manager entry that currently has the focus, and can only be specified inside of a
Color
or
Monochrome
list\&. The optional
win\-list
is a list of window names and colors so that per\-window colors may be specified\&. See the
BorderColor
variable for a complete description of the
win\-list\&. The default is \(lqblack\(rq\&.
.RE
.PP
IconManagers { iconmgr\-list }
.RS 4
This variable specifies a list of icon managers to create\&. Each item in the
iconmgr\-list
has the following format:
.sp
.if n \{\
.RS 4
.\}
.nf
    "winname" ["iconname"] "geometry" columns
.fi
.if n \{\
.RE
.\}
.sp
where
winname
is the name of the windows that should be put into this icon manager,
iconname
is the name of that icon manager window\(cqs icon,
geometry
is a standard geometry specification, and
columns
is the number of columns in this icon manager as described in
IconManagerGeometry\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
IconManagers
{
    "XTerm"  "=300x5+800+5"  5
    "myhost" "=400x5+100+5"  2
}
.fi
.if n \{\
.RE
.\}
.sp
Clients whose name or class is \(lqXTerm\(rq will have an entry created in the \(lqXTerm\(rq icon manager\&. Clients whose name was \(lqmyhost\(rq would be put into the \(lqmyhost\(rq icon manager\&.
.RE
.PP
IconManagerShadowDepth pixels
.RS 4
This variable specifies the depth of the shadow ctwm uses for 3D IconManager entries, when UseThreeDIconManagers is selected\&.
.RE
.PP
IconManagerShow { win\-list }
.RS 4
This variable specifies a list of windows that should appear in the icon manager\&. When used in conjunction with the
IconManagerDontShow
variable, only the windows in this list will be shown in the icon manager\&.
.RE
.PP
IconMenuDontShow { win\-list }
.RS 4
Don\(cqt show the name of these windows in the TwmIcons menu\&.
.RE
.PP
IconRegion geomstring vgrav hgrav gridwidth gridheight [iconjust] [iconregjust] [iconregalign] [{ win\-list }]
.RS 4
This variable specifies an area on the root window in which icons are placed if no specific icon location is provided by the client\&. The
geomstring
is a quoted string containing a standard geometry specification\&. If more than one
IconRegion
lines are given, icons will be put into the succeeding icon regions when the first is full\&. The
vgrav
argument should be either
North
or
South
and is used to control whether icons are first filled in from the top or bottom of the icon region\&. Similarly, the
hgrav
argument should be either
East
or
West
and is used to control whether icons should be filled in from left or from the right\&. Icons are laid out within the region in a grid with cells
gridwidth
pixels wide and
gridheight
pixels high\&. The optional win\-list argument tells ctwm that if such a window is iconified, and there is enough room in this icon region for its icon, then place it here\&. The optional
iconjust,
iconregjust
and
iconregalign
can be used to give specific values of IconJustification, IconRegionJustification and IconRegionAlignement for this IconRegion\&.
.RE
.PP
IconRegionAlignement string
.RS 4
Where string is either
"top",
"center"
"bottom"
or
"border"\&. Tells ctwm how to align icons inside their place in the IconRegion\&. If \(lqborder\(rq is given, the justification will be \(lqtop\(rq if the icon region gravity is \(lqnorth\(rq and \(lqbottom\(rq if the icon region gravity is \(lqsouth\(rq\&.
.RE
.PP
IconRegionJustification string
.RS 4
Where string is either
"left",
"center"
"right"
or
"border"\&. Tells ctwm how to justify icons inside their place in the IconRegion\&. If \(lqborder\(rq is given, the justification will be \(lqleft\(rq if the icon region gravity is \(lqwest\(rq and \(lqright\(rq if the icon region gravity is \(lqeast\(rq\&.
.RE
.PP
Icons { win\-list }
.RS 4
This variable specifies a list of window names and the bitmap filenames that should be used as their icons\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
Icons
{
    "XTerm"  "xterm\&.icon"
    "xfd"    "xfd_icon"
}
.fi
.if n \{\
.RE
.\}
.sp
Windows that match \(lqXTerm\(rq and would not be iconified by unmapping, would try to use the icon bitmap in the file \(lqxterm\&.icon\(rq\&.If
ForceIcons
is specified, this bitmap will be used even if the client has requested its own icon pixmap\&.
.RE
.PP
IconSize string
.RS 4
(Only if built with
USE_EWMH) string is of the form "<width>x<height>" or "size" for a square size\&. This indicates the preferred size of icons selected from the EWMH window property
_NET_WM_ICON\&. If an icon with the exact size is not available, one with the nearest (area) size will be chosen\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
IgnoreCaseInMenuSelection
.RS 4
Used when moving the pointer inside a menu with the keyboard\&. When you type a letter, the pointer goes to the next entry beginning with this letter\&. If IgnoreCaseInMenuSelection is present, this selection ignores the case of this first letter\&.
.RE
.PP
IgnoreLockModifier
.RS 4
If present, all bindings (buttons and keys) will ignore the LockMask\&. Useful if you often use caps lock, and don\(cqt want to define twice all your bindings\&.
.RE
.PP
IgnoreModifier
.RS 4
All bindings (buttons and keys) will ignore the modifiers you specified\&. It is useful when you use caps locks or num locks\&. You don\(cqt need IgnoreLockModifier any more with this option\&.
.sp
.if n \{\
.RS 4
.\}
.nf
IgnoreModifier { lock m2 }
.fi
.if n \{\
.RE
.\}
.RE
.PP
IgnoreTransient
.RS 4
List of windows for which to ignore transients\&.
.sp
.if n \{\
.RS 4
.\}
.nf
IgnoreTransient { "Wine" }
.fi
.if n \{\
.RE
.\}
.RE
.PP
InterpolateMenuColors
.RS 4
This variable indicates that menu entry colors should be interpolated between entry specified colors\&. In the example below:
.sp
.if n \{\
.RS 4
.\}
.nf
Menu "mymenu"
{
    "Title"     ("black":"red")     f\&.title
    "entry1"                        f\&.nop
    "entry2"                        f\&.nop
    "entry3"    ("white":"green")   f\&.nop
    "entry4"                        f\&.nop
    "entry5"    ("red":"white")     f\&.nop
}
.fi
.if n \{\
.RE
.\}
.sp
the foreground colors for \(lqentry1\(rq and \(lqentry2\(rq will be interpolated between black and white, and the background colors between red and green\&. Similarly, the foreground for \(lqentry4\(rq will be half\-way between white and red, and the background will be half\-way between green and white\&.
.RE
.PP
MakeTitle { win\-list }
.RS 4
This variable specifies a list of windows on which a titlebar should be placed and is used to request titles on specific windows when
NoTitle
has been set\&.
.RE
.PP
MapWindowBackground color [{ win\-list }]
.RS 4
This variable specifies the background colors to use for small windows in the workspace map window and may only be specified inside of a Color or Monochrome list\&. The optional
win\-list
is a list of window names and colors so that per\-window colors may be specified\&. If there is neither MapWindowBackground, nor MapWindowForeground the window title colors are used\&.
.RE
.PP
MapWindowCurrentWorkSpace { border_color [background] [foreground] [bitmap] }
.RS 4
Specify the appearence of the map window corresponding to the current workspace\&.
.RE
.PP
MapWindowDefaultWorkSpace { border_color [background] [foreground] [bitmap] }
.RS 4
Specify the appearence of the map window corresponding to the workspaces other than the current workspace when no root background information has been provided to ctwm in the WorkSpace command\&. Not used in others cases\&.
.RE
.PP
MapWindowForeground color [{ win\-list }]
.RS 4
This variable specifies the foreground colors to use for small windows in the workspace map window and may only be specified inside of a Color or Monochrome list\&. The optional
win\-list
is a list of window names and colors so that per\-window colors may be specified\&. If there is neither MapWindowBackground, nor MapWindowForeground the window title colors are used\&.
.RE
.PP
MaxIconTitleWidth width
.RS 4
The integer argument tells ctwm the maximun width to use for an icon title\&. If an icon title is larger than
width, it is truncated\&.
.RE
.PP
MaxWindowSize string
.RS 4
This variable specifies a geometry in which the width and height give the maximum size for a given window\&. This is typically used to restrict windows to the size of the screen\&. The default is \(lq30000x30000\(rq\&.
.RE
.PP
MenuBackground string
.RS 4
This variable specifies the background color used for menus, and can only be specified inside of a
Color
or
Monochrome
list\&. The default is \(lqwhite\(rq\&.
.RE
.PP
MenuFont string
.RS 4
This variable specifies the font to use when displaying menus\&. The default is \(lqvariable\(rq\&.
.RE
.PP
MenuForeground string
.RS 4
This variable specifies the foreground color used for menus, and can only be specified inside of a
Color
or
Monochrome
list\&. The default is \(lqblack\(rq\&.
.RE
.PP
MenuShadowColor string
.RS 4
This variable specifies the color of the shadow behind pull\-down menus and can only be specified inside of a
Color
or
Monochrome
list\&. The default is \(lqblack\(rq\&.
.RE
.PP
MenuShadowDepth pixels
.RS 4
This variable specifies the depth of the shadow ctwm uses for 3D menus, when UseThreeDMenus is selected\&.
.RE
.PP
MenuTitleBackground string
.RS 4
This variable specifies the background color for
f\&.title
entries in menus, and can only be specified inside of a
Color
or
Monochrome
list\&. The default is \(lqwhite\(rq\&.
.RE
.PP
MenuTitleForeground string
.RS 4
This variable specifies the foreground color for
f\&.title
entries in menus and can only be specified inside of a
Color
or
Monochrome
list\&. The default is \(lqblack\(rq\&.
.RE
.PP
Monochrome { colors }
.RS 4
This variable specifies a list of color assignments that should be made if the screen has a depth of 1\&. See the description of
Color\&.
.RE
.PP
MoveDelta pixels
.RS 4
This variable specifies the number of pixels the pointer must move before the
f\&.move
function starts working\&. Also see the
f\&.deltastop
function\&. The default is zero pixels\&.
.RE
.PP
MovePackResistance pixels
.RS 4
This variable specifies the number of pixels of the movepack and movepush resistance\&. See
f\&.movepack
and
f\&.movepush\&.
.RE
.PP
MoveOffResistance pixels
.RS 4
This variable specifies the number of pixels of the moveoff resistance\&. If
pixels
is positive,
DontMoveOff
will only prevent you from going off the edge if you\(cqre within n pixels off the edge\&. If you go further,
DontMoveOff
gives up and lets you go as far as you wish\&.
f\&.forcemove
still allows you to totally ignore
DontMoveOff\&. A negative value puts you back into \(lqnever moveoff\(rq mode (it\(cqs the default)\&.
.RE
.PP
MWMIgnore
.RS 4
Sets Motif window manager hints ctwm will ignore\&. The following example shows all the valid options:
.sp
.if n \{\
.RS 4
.\}
.nf
MWMIgnore
{
    # en/disable window borders
    "DECOR_BORDER"

    # en/disable titlebars
    "DECOR_TITLE"
}
.fi
.if n \{\
.RE
.\}
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
NoBackingStore
.RS 4
This variable indicates that ctwm\(cqs menus should not request backing store to minimize repainting of menus\&. This is typically used with servers that can repaint faster than they can handle backing store\&. See also
BackingStore\&. As of 4\&.0\&.0 this is the default\&.
.RE
.PP
NoBorder { win\-list }
.RS 4
These windows won\(cqt have borders\&. If you want no borders on all windows, use the BorderWidth keyword\&.
.RE
.PP
NoCaseSensitive
.RS 4
This variable indicates that case should be ignored when sorting icon names in an icon manager\&. This option is typically used with applications that capitalize the first letter of their icon name\&.
.RE
.PP
NoDecorateTransients
.RS 4
Specify that transient windows (i\&.e\&., windows with a
WM_TRANSIENT_FOR
property set) should be ignored (not given decorations) by ctwm\&. See also
DecorateTransients\&. Added in 4\&.0\&.0; in previous versions this was the default\&.
.RE
.PP
NoDefaults
.RS 4
This variable indicates that ctwm should not supply the default titlebuttons and bindings\&. This option should only be used if the startup file contains a completely new set of bindings and definitions\&.
.RE
.PP
NoGrabServer
.RS 4
This variable indicates that ctwm should not grab the server when popping up menus and moving opaque windows\&. As of 4\&.0\&.0 this is the default\&.
.RE
.PP
NoHighlight [{ win\-list }]
.RS 4
This variable indicates that borders should not be highlighted to track the location of the pointer\&. If the optional
win\-list
is given, highlighting will only be disabled for those windows\&. When the border is highlighted, it will be drawn in the current
BorderColor\&. When the border is not highlighted, it will be stippled with an gray pattern using the current
BorderTileForeground
and
BorderTileBackground
colors\&.
.RE
.PP
NoIconTitle [{ win\-list }]
.RS 4
This variable indicates that icons should not display the icon name of the client\&. If the optional
win\-list
is given, only those clients will not have icon titles\&.
.RE
.PP
NoIconManagerFocus
.RS 4
This variable indicates that ctwm will not set the focus on the corresponding window when the pointer is in an IconManager\&.
.RE
.PP
NoIconManagers
.RS 4
This variable indicates that no icon manager should be created\&.
.RE
.PP
NoImagesInWorkSpaceManager
.RS 4
This variable turns off displaying of background images in the WorkSpaceMap\&. Instead only the colors defined in
WorkSpaces
will be used as background in the WorkSpaceMap\&.
.RE
.PP
NoMenuShadows
.RS 4
This variable indicates that menus should not have drop shadows drawn behind them\&. This is typically used with slower servers since it speeds up menu drawing at the expense of making the menu slightly harder to read\&.
.RE
.PP
NoOpaqueMove [{ window\-list }]
.RS 4
The counterpart of
OpaqueMove\&. See
OpaqueMove\&.
.RE
.PP
NoOpaqueResize [{ window\-list }]
.RS 4
The counterpart of
OpaqueResize\&. See
OpaqueResize\&.
.RE
.PP
NoRaiseOnDeiconify
.RS 4
This variable indicates that windows that are deiconified should not be raised\&.
.RE
.PP
NoRaiseOnMove
.RS 4
This variable indicates that windows should not be raised when moved\&. This is typically used to allow windows to slide underneath each other\&.
.RE
.PP
NoRaiseOnResize
.RS 4
This variable indicates that windows should not be raised when resized\&. This is typically used to allow windows to be resized underneath each other\&.
.RE
.PP
NoRaiseOnWarp
.RS 4
This variable indicates that windows should not be raised when the pointer is warped into them with the
f\&.warpto
function\&. If this option is set, warping to an occluded window may result in the pointer ending up in the occluding window instead the desired window (which causes unexpected behavior with
f\&.warpring)\&.
.RE
.PP
NoRestartPreviousState
.RS 4
Don\(cqt attempt to regenerate the state the screen was in before the previous window manager was shut down\&. See
RestartPreviousState
for details\&. Added in 4\&.0\&.0; in previous versions this was the default\&.
.RE
.PP
NoSaveUnders
.RS 4
This variable indicates that menus should not request save\-unders to minimize window repainting following menu selection\&. It is typically used with displays that can repaint faster than they can handle save\-unders\&.
.RE
.PP
NoShowOccupyAll
.RS 4
This variable specifies that OccupyAll windows won\(cqt be displayed in the WorkSpaceMap window\&.
.RE
.PP
NoSortIconManager
.RS 4
Specifies that entries in the icon manager should be appended in the order they show up\&. See also
SortIconManager\&. Added in 4\&.0\&.0; in previous versions this was the default\&.
.RE
.PP
NoStackMode [{ win\-list }]
.RS 4
This variable indicates that client window requests to change stacking order should be ignored\&. If the optional
win\-list
is given, only requests on those windows will be ignored\&. This is typically used to prevent applications from relentlessly popping themselves to the front of the window stack\&.
.RE
.PP
NoTitle [{ win\-list }]
.RS 4
This variable indicates that windows should not have titlebars\&. If the optional
win\-list
is given, only those windows will not have titlebars\&.
MakeTitle
may be used with this option to force titlebars to be put on specific windows\&.
.RE
.PP
NoTitleFocus
.RS 4
This variable indicates that ctwm should not set keyboard input focus to each window as it is entered\&. Normally, ctwm sets the focus so that focus and key events from the titlebar and icon managers are delivered to the application\&. If the pointer is moved quickly and ctwm is slow to respond, input can be directed to the old window instead of the new\&. This option is typically used to prevent this \(lqinput lag\(rq and to work around bugs in older applications that have problems with focus events\&.
.RE
.PP
NoTitleHighlight [{ win\-list }]
.RS 4
This variable indicates that the highlight area of the titlebar, which is used to indicate the window that currently has the input focus, should not be displayed\&. If the optional
win\-list
is given, only those windows will not have highlight areas\&. This and the
SqueezeTitle
options can be set to substantially reduce the amount of screen space required by titlebars\&.
.RE
.PP
NoWarpToMenuTitle
.RS 4
This variable indicates that the cursor should not be warped to the title of a menu which does not have room to drop down below the current cursor position\&.
.RE
.PP
Occupy { occupy\-list }
.RS 4
This variable specifies which windows occupy which workspaces at startup\&.
.sp
occupy\-list
consists of entries of the form :
.sp
.if n \{\
.RS 4
.\}
.nf
        [Window]   win\-name  { wspc1 wspc2 \&.\&.\&. }
or      Workspace  wspc\-name { win1  win2 \&.\&.\&.  }
.fi
.if n \{\
.RE
.\}
.sp
Example :
.sp
.if n \{\
.RS 4
.\}
.nf
Occupy
{
               "xload"   {"all"}
    Window     "xterm"   {"here" "there" "elsewhere"}
               "xv"      {"images"}
    WorkSpace  "images"  {"xloadimage"}
}
.fi
.if n \{\
.RE
.\}
.sp
If
all
is given for the workspace name (in either form), the named window[s] will be put in all workspaces as if they were listed in
OccupyAll\&. If the workspace name begins with
ws:, the workspace name will be looked up without the prefix first\&. That is, if the given name is
ws:abc, it will first look for a workspace called
abc, and assign to that if found\&. Else it will fall back to looking for the name
ws:abc\&.
.sp
Note : The Occupy declaration should come after the WorkSpaces declaration\&.
.RE
.PP
OccupyAll { window\-list }
.RS 4
This variable specifies a list of windows that will occupy all workspaces at startup\&.
.sp
window\-list
is a list of window names\&.
.sp
Example :
.sp
.if n \{\
.RS 4
.\}
.nf
OccupyAll
{
    "xload"
    "xbiff"
    "xconsole"
}
.fi
.if n \{\
.RE
.\}
.sp
Note : The OccupyAll declaration should come after the WorkSpaces declaration\&.
.RE
.PP
OnTopPriority [Icons] priority [ { win\-list } ]
.RS 4
ctwm allows you to put windows in several overlapping priority planes going from \-8 to +8, which makes it possible to have windows that stay on top or that are kept in the background\&. If
win\-list
is present, it specifies which windows should be put in the
priority
plane\&. Else the
priority
sets the default value to use (the default default is 0)\&. The
Icons
parameter, if present, indicates that the preference described applies to icons rather than to windows\&.
.sp
Example:
.sp
.if n \{\
.RS 4
.\}
.nf
OnTopPriority Icons \-1  # place icons a little in the background
OnTopPriority Icons 1   # place mail icons on top of normal windows
{
    "Exmh"
    "xbiff"
}

OnTopPriority 8         # keep these always on top of other windows
{
    "Emacs Icon Manager" "WorkSpaceManager"
    "TWM Icon Manager" "XDaliClock"
}
.fi
.if n \{\
.RE
.\}
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
OpaqueMove [{ window\-list }]
.RS 4
This variable indicates that the
f\&.move
function should actually move the window instead of just an outline so that the user can immediately see what the window will look like in the new position\&. This option is typically used on fast displays (particularly if
NoGrabServer
is set)\&. The optional window list parameter indicates that only windows in this list should actually be moved in opaque mode\&. The
NoOpaqueMove
counterpart is also available\&.
.sp
As of 4\&.0\&.0 this is enabled by default\&.
.RE
.PP
OpaqueMoveThreshold threshold
.RS 4
The integer parameter is a percentage and indicates that only windows (elligible for opaque moving) with a surface smaller than this percentage of the surface of the screen should actually be moved in opaque mode\&. The default is 200\&. Since 4\&.0\&.0, values >= 200 are treated as infinity, causing windows to always
OpaqueMove
if eligible\&.
.RE
.PP
OpaqueResize [{ window\-list }]
.RS 4
The opaque version of resize\&. Extremely resource intensive, but beautiful with fast server/client/network\&. See
OpaqueMove\&. The
NoOpaqueResize
counterpart is also available\&. As of 4\&.0\&.0 this is enabled by default\&.
.RE
.PP
OpaqueResizeThreshold threshold
.RS 4
The resize version of
OpaqueMoveThreshold\&. The default is 1000\&. Since 3\&.8\&.1, values >= 1000 are treated as infinity, causing windows to always
OpaqueResize
if eligible\&.
.RE
.PP
OpenWindowTimeout seconds
.RS 4
seconds is an integer representing a number of second\&. When a window tries to open on an unattended display, it will be automatically mapped after this number of seconds\&.
.RE
.PP
PackNewWindows
.RS 4
Use f\&.movepack algorithm instead of f\&.move when opening a new window\&.
.RE
.PP
Pixmaps { pixmaps }
.RS 4
This variable specifies a list of pixmaps that define the appearance of various images\&. Each entry is a keyword indicating the pixmap to set, followed by a string giving the name of the bitmap file\&. The following pixmaps may be specified:
.sp
.if n \{\
.RS 4
.\}
.nf
Pixmaps
{
        TitleHighlight  "gray1"
#       TitleHighlight  "supman%\&.xbm"
}
.fi
.if n \{\
.RE
.\}
.sp
The default for
TitleHighlight
is to use an even stipple pattern\&.
.RE
.PP
PixmapDirectory path
.RS 4
This variable specifies the path where ctwm looks to find non\-X11 bitmap files\&. Whenever you want to use a image file that is not an X11 bitmap, specify :
xpm:filename
for xpm files,
xwd:filename
for xwd files,
jpeg:file
for jpeg file, or
|command
for an on the fly generated xwd file\&. Use the % character to specify an animation\&.
path
can be a colon separated list of directories\&. Example :
.sp
.if n \{\
.RS 4
.\}
.nf
PixmapDirectory  "/usr/lib/X11/twm"
Icons
{
    "Axe"    "xpm:edit\&.xpm"
    "xterm"  "xpm:ball%\&.xpm"
}
.fi
.if n \{\
.RE
.\}
.sp
N\&.B This is only valid if your version of ctwm has been compiled with the right extension (XPM or JPEG)\&.
.RE
.PP
PrioritySwitching [Icons] { win\-list }
.RS 4
Specifies that the windows in
win\-list
can switch priority\&. This means that they can be in plane
priority
or
\-priority
depending on the situation\&. For instance a window whose
priority
is 2 will be put into plane 2 when raised and plane \-2 when lowered, which means that it will usually stay on top if you raise another window, but can still be lowered if its priority is temporarily too high for your liking\&. If
Icons
is specified, it means that the preference applies to icons rather than windows\&. See also the
f\&.priorityswitching
function for dynamically adding/removing windows at runtime\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
PriorityNotSwitching [Icons] { win\-list }
.RS 4
As above except that it declares that the default should be for windows to be able to switch priority except for the windows in
win\-list
which can\(cqt\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
RaiseDelay milliseconds
.RS 4
For windows that are to be automatically raised when the pointer enters (see the
AutoRaise
variable and the
f\&.autoraise
function) this variable specifies the length of time the pointer should rest in the window before it is raised\&. The default is 0 milliseconds\&.
.RE
.PP
RaiseOnClick
.RS 4
If present a window will be raised on top of others when clicked on, and the ButtonPress event will be correctly forwarded to the client that owns this window (if it asked to)\&. See
RaiseOnClickButton\&.
.RE
.PP
RaiseOnClickButton button_number
.RS 4
Where
button_number
is a valid button number (currently 1 to 11)\&. Specify the button to use for RaiseOnClick\&.
.RE
.PP
RaiseWhenAutoUnSqueeze
.RS 4
Windows are raised when auto\-unsqueezed (See AutoSqueeze)\&.
.RE
.PP
RandomPlacement [ string1 [ string2 ]]
.RS 4
This variable indicates that windows with no specified geometry should be placed in a pseudo\-random location instead of having the user drag out an outline\&. If no argument is given, it is interpreted as
RandomPlacement "on"\&.
.sp
string1
may be \(lqon\(rq, \(lqoff\(rq, \(lqall\(rq or \(lqunmapped\(rq, and
string2
is a displacement for the pseudo\-randomly placed window compared to the previous one\&. The argument \(lqon\(rq or \(lqall\(rq are equivalent, and tell ctwm to do this for all such windows, \(lqoff\(rq, not to do this, and \(lqunmapped\(rq, only for unmapped windows, e\&.g\&. iconified or not visible in the current workspace\&. If the second argument isn\(cqt given, the displacement +30+30 (30 pixels right and down) is used\&.
.sp
As of 4\&.0\&.0, \(lqon\(rq is the default if no
RandomPlacement
is specified in the config\&. Previously \(lqoff\(rq was default\&.
.RE
.PP
ReallyMoveInWorkspaceManager
.RS 4
This keyword tells ctwm to move the actual window when the user is moving the small windows in the WorkSpaceMap window\&. If not present the WorkSpaceMap can be used only to modify the occupation of a window\&. Pressing the
shift
key while dragging a window in the workspace manager temporarily toggles this option\&.
.RE
.PP
ResizeFont string
.RS 4
This variable specifies the font to be used for in the dimensions window when resizing windows\&. The default is \(lqfixed\(rq\&.
.RE
.PP
RestartPreviousState
.RS 4
This variable indicates that properties on client windows to attempt to regenerate the state that the screen was in before the previous window manager was shutdown\&. This includes using the
WM_STATE
property to tell which windows should be iconified and which should be left visible, and the
WM_OCCUPATION
property to determine in which workspaces a window should be visible\&. As of 4\&.0\&.0 this is the default\&.
.RE
.PP
ReverseCurrentWorkspace
.RS 4
This variable tells ctwm to reverse the background and foreground colors in the small windows in the workspace map for the current workspace\&.
.RE
.PP
RplaySoundHost string
.RS 4
The host on which sounds should be played\&. Only meaningful when ctwm is built with
USE_SOUND; will give a warning otherwise\&. See the SOUNDS section\&. Added in 4\&.0\&.0; prior versions used the
SoundHost
parameter instead\&.
.RE
.PP
RplaySounds { sounds\-list }
.RS 4
Define what sounds to play on various events through rplayd\&. It contains entries of the form
.sp
.if n \{\
.RS 4
.\}
.nf
    "EventName"   "/file/to/play\&.wav"
.fi
.if n \{\
.RE
.\}
.sp
Only meaningful when ctwm is built with
USE_SOUND; it will give a warning otherwise\&. See the SOUNDS section\&. Note that if this section is given in the ctwmrc, the
~/\&.ctwm\-sounds
file will not be parsed\&. First appeared in 4\&.0\&.0\&.
.RE
.PP
SaveColor { colors\-list }
.RS 4
This variable indicates a list of color assignments to be stored as pixel values in the root window property _MIT_PRIORITY_COLORS\&. Clients may elect to preserve these values when installing their own colormap\&. Note that use of this mechanism is a way for an application to avoid the \(lqtechnicolor\(rq problem, whereby useful screen objects such as window borders and titlebars disappear when a program\(cqs custom colors are installed by the window manager\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
SaveColor
{
    BorderColor
    TitleBackground
    TitleForeground
    "red"
    "green"
    "blue"
}
.fi
.if n \{\
.RE
.\}
.sp
This would place on the root window 3 pixel values for borders and titlebars, as well as the three color strings, all taken from the default colormap\&.
.RE
.PP
ShrinkIconTitles
.RS 4
A la Motif shrinking of icon titles, and expansion when mouse is inside icon\&. The old incorrect spelling
SchrinkIconTitles
is also still accepted\&.
.RE
.PP
ShortAllWindowsMenus
.RS 4
Don\(cqt show WorkSpaceManager and IconManagers in the TwmWindows and TwmAllWindows menus\&.
.RE
.PP
ShowIconManager
.RS 4
This variable indicates that the icon manager window should be displayed when ctwm is started\&. It can always be brought up using the
f\&.showiconmgr
function\&.
.RE
.PP
ShowWorkSpaceManager
.RS 4
This variable specifies that the WorkSpaceManager should be visible\&.
.RE
.PP
SloppyFocus
.RS 4
Use sloppy focus\&.
.RE
.PP
SaveWorkspaceFocus
.RS 4
When changing to a workspace, restore the focus to the last window that had the focus when you left the workspace by warping the mouse into it\&. This essentially saves the focus window with the workspace and restores it automatically when you switch\&. In many cases, it avoids having to reach for the mouse after moving to a new workspace\&.
.RE
.PP
SortIconManager
.RS 4
This variable indicates that entries in the icon manager should be sorted alphabetically rather than by simply appending new windows to the end\&. As of 4\&.0\&.0 this is the default\&.
.RE
.PP
SoundHost string
.RS 4
Alias for
RplaySoundHost, used in versions prior to 4\&.0\&.0\&. Unless you need backward compatibility with them, use
RplaySoundHost
instead\&. This alias will be removed in a future version\&.
.RE
.PP
SqueezeTitle [{ squeeze\-list }]
.RS 4
This variable indicates that ctwm should attempt to use the SHAPE extension to make titlebars occupy only as much screen space as they need, rather than extending all the way across the top of the window\&. The optional
squeeze\-list
may be used to control the location of the squeezed titlebar along the top of the window\&. It contains entries of the form:
.sp
.if n \{\
.RS 4
.\}
.nf
    "name"  justification num denom
.fi
.if n \{\
.RE
.\}
.sp
where
name
is a window name,
justification
is either
left,
center, or
right, and
num
and
denom
are numbers specifying a ratio giving the relative position about which the titlebar is justified\&. The ratio is measured from left to right if the numerator is positive, and right to left if negative\&. A denominator of 0 indicates that the numerator should be interpreted as pixels\&. For compatibility, the pixel\-position 0/0 is the relative middle of the window (1/2) for
center
and the relative right side of the window (2/2) for
right, but this use is not recommended\&. Use "right 2 2" for relative positioning, or "right \-1 0" for absolute; this makes a difference when dragging the titlebar (see
f\&.movetitlebar)\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
SqueezeTitle
{
    "XTerm"   left    0  0
    "xterm1"  left    1  3
    "xterm2"  left    2  3
    "oclock"  center  1  2
    "emacs"   right   2  2
}
.fi
.if n \{\
.RE
.\}
.sp
The default positioning is left\-justified, absolute at 0 pixels\&. The
DontSqueezeTitle
list can be used to turn off squeezing on certain titles\&.
.RE
.PP
StartIconified { win\-list }
.RS 4
This variable indicates that client windows should initially be left as icons until explicitly deiconified by the user\&. If the optional
win\-list
is given, only those windows will be started iconic\&. This is useful for programs that do not support an
\-iconic
command line option or resource\&.
.RE
.PP
StartInButtonState
.RS 4
Start the WorkSpaceManage in button form\&. See also
StartInMapState\&. Added in 4\&.0\&.0\&.
.RE
.PP
StartInMapState
.RS 4
This variable specifies that the WorkSpaceManager should be started in its map form when created\&. See also
StartInButtonState\&. As of 4\&.0\&.0 this is the default\&.
.RE
.PP
StartSqueezed { win\-list }
.RS 4
These windows will first show up squeezed (see f\&.squeeze)\&.
.RE
.PP
StayUpMenus
.RS 4
Tells ctwm to use stayup menus\&. These menus will stay on the screen when ButtonUp, if either the menu has not yet been entered by the pointer, or the current item is a f\&.title\&.
.RE
.PP
StrictWinNameEncoding
.RS 4
Whether to be strict about what encodings we accept for window naming properties\&. Added in 4\&.0\&.2\&.
.sp
This is used when translating properties relating to naming windows, like
WM_NAME\&. For example, according to the ICCCM,
WM_NAME
can only be a
STRING
or
COMPOUND_TEXT
type\&. However, sloppy programs like Chrome may set it to a
UTF8_STRING
instead\&. If this var is set, ctwm will reject that, as was standard behavior prior to 4\&.0\&.2\&.
.RE
.PP
SunkFocusWindowTitle
.RS 4
This variable specifies that the title of the focus window (if exists) should be sunken instead of raised\&. Only valid if UseThreeDTitles is set\&.
.RE
.PP
ThreeDBorderWidth pixels
.RS 4
The width of the 3D border in pixels, if any\&.
.RE
.PP
TitleBackground string [{ win\-list }]
.RS 4
This variable specifies the background color used in titlebars, and may only be specified inside of a
Color
or
Monochrome
list\&. The optional
win\-list
is a list of window names and colors so that per\-window colors may be specified\&. The default is \(lqwhite\(rq\&.
.RE
.PP
TitleButtonBorderWidth pixels
.RS 4
This variable specifies the width in pixels of the border surrounding titlebuttons\&. This is typically set to 0 to allow titlebuttons to take up as much space as possible and to not have a border\&. The default is 1 if
UseThreeDTitles
is not set, 0 if it is set\&.
.RE
.PP
TitleButtonShadowDepth pixels
.RS 4
This variable specifies the depth of the shadow ctwm uses for 3D title buttons, when UseThreeDTitles is selected\&.
.RE
.PP
TitleFont string
.RS 4
This variable specifies the font used for displaying window names in titlebars\&. The default is \(lqvariable\(rq\&.
.RE
.PP
TitleForeground string [{ win\-list }]
.RS 4
This variable specifies the foreground color used in titlebars, and may only be specified inside of a
Color
or
Monochrome
list\&. The optional
win\-list
is a list of window names and colors so that per\-window colors may be specified\&. The default is \(lqblack\(rq\&.
.RE
.PP
TitleJustification string
.RS 4
This keyword needs a string value\&. The acceptable values are : \(lqleft\(rq, \(lqcenter\(rq and \(lqright\(rq\&. The window titles will be justified according to this in the title window\&.
.RE
.PP
TitlePadding pixels
.RS 4
This variable specifies the distance between the various buttons, text, and highlight areas in the titlebar\&. The default is 8 pixels if
UseThreeDTitles
is not set, 0 if it is set\&.
.RE
.PP
TitleShadowDepth pixels
.RS 4
This variable specifies the depth of the shadow ctwm uses for 3D titles, when UseThreeDTitles is selected\&.
.RE
.PP
TransientHasOccupation
.RS 4
This variable specifies that transient\-for and non\-group leader windows can have their own occupation potentially different from their leader window\&. The default case is that these windows follow their leader, use this keyword if the default action doesn\(cqt please you\&.
.RE
.PP
TransientOnTop percentage
.RS 4
The parameter (required) is a percentage and tells ctwm to put transient (and non\-group leader) windows always on top of their leader if and only if their surface is smaller than this fraction of the surface of their leader\&. The surface of a window is its width times its weight\&. The default is 30%\&. Added in 3\&.0\&.
.RE
.PP
UnknownIcon string
.RS 4
This variable specifies the filename of a bitmap file to be used as the default icon\&. This bitmap will be used as the icon of all clients which do not provide an icon bitmap and are not listed in the
Icons
list\&.
.RE
.PP
UnmapByMovingFarAway { win\-list }
.RS 4
These windows will be moved out of the screen instead of being unmapped when they become invisible due to a change workspace\&. This has been added because some ill\-behaved clients (Frame5) don\(cqt like to be unmapped\&.
.RE
.PP
UsePPosition string
.RS 4
This variable specifies whether or not ctwm should honor program\-requested locations (given by the
PPosition
flag in the
WM_NORMAL_HINTS
property) in the absence of a user\-specified position\&. The argument
string
may have one of three values:
"off"
(the default) indicating that ctwm should ignore the program\-supplied position,
"on"
indicating that the position should be used, and
"non\-zero"
indicating that the position should used if it is other than (0,0)\&. The latter option is for working around a bug in older toolkits\&.
.RE
.PP
UseSunkTitlePixmap
.RS 4
This makes it so the shadows are inversed for title pixmaps when focus is lost\&. This is similar to having the SunkFocusWindowTitle, but it makes your xbm or 3d XPM (if any) sink instead of just the whole bar\&.
.RE
.PP
UseThreeDBorders
.RS 4
Tells ctwm to use 3D\-looking window borders\&. The width ot the 3D borders is
ThreeDBorderWidth\&. The color of the 3D border is
BorderTileBackground, and if NoHighlight is not selected, the border of the Focus window is
BorderColor\&. Setting this automatically unsets
ClientBorderWidth\&.
.RE
.PP
UseThreeDIconManagers
.RS 4
Tells ctwm to use 3D\-looking IconManagers if any\&.
.RE
.PP
UseThreeDMenus
.RS 4
Tells ctwm to use 3D\-looking menus\&.
.RE
.PP
UseThreeDTitles
.RS 4
Tells ctwm to use 3D\-looking windows titles\&. In which case the default values of
TitleButtonBorderWidth,
FramePadding,
TitlePadding
and
ButtonIndent
are set to 0\&. There are plenty of built\-in scalable pixmaps for buttons:
:xpm:menu,
:xpm:dot,
:xpm:cross,
:xpm:bar,
:xpm:vbar,
:xpm:iconify,
:xpm:resize,
:xmp:sunkresize, and
:xpm:box\&. There are several built\-in scalable animations for buttons:
%xpm:resize,
%xpm:menu\-up,
%xpm:menu\-down,
%xpm:resize\-out\-top,
%xpm:resize\-in\-top,
%xpm:resize\-out\-bot,
%xpm:resize\-in\-bot,
%xpm:maze\-out,
%xpm:maze\-in,
%xpm:zoom\-out,
%xpm:zoom\-in, and
%xpm:zoom\-inout\&. Try them to see what they look like\&.
.RE
.PP
UseThreeDWMap
.RS 4
Tells ctwm to use 3D for the small windows in the workspace map\&.
.RE
.PP
VirtualScreens { geometries\-list }
.RS 4
This variable specifies a list of geometries for virtual screens\&. Virtual screens are designed to be used when you have several physical screens bound together with the Xinerama X extension\&.
.sp
geometries\-list
is a list of valid geometry strings, that correspond to your actual physical screens\&.
.sp
Example :
.sp
.if n \{\
.RS 4
.\}
.nf
VirtualScreens
{
    "1280x1024+0+0"
    "1600x1200+1280+0"
}
.fi
.if n \{\
.RE
.\}
.RE
.PP
WarpCursor [{ win\-list }]
.RS 4
This variable indicates that the pointer should be warped into windows when they are deiconified\&. If the optional
win\-list
is given, the pointer will only be warped when those windows are deiconified\&.
.RE
.PP
WarpOnDeIconify { win\-list }
.RS 4
When ctwm receives a request to map a window, it normally just deiconifies it, but if the window is in
win\-list, it will additionally bring it into the current workspace, if necessary\&. For example
.sp
.if n \{\
.RS 4
.\}
.nf
WarpOnDeIconify { "Emacs" }
.fi
.if n \{\
.RE
.\}
.sp
will make sure emacs windows will always popup in the current workspace when necessary (typically when the minibuffer or the
\fBHelp\fR
frame is in another workspace)\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
WarpRingOnScreen
.RS 4
Tells ctwm that f\&.warpring warps pointer only to windows visible in the current workspace\&.
.RE
.PP
WarpToDefaultMenuEntry
.RS 4
(Useful only with StayUpMenus) When using StayUpMenus, and a menu does stays up, the pointer is warped to the default entry of the menu\&.
.RE
.PP
WarpUnmapped
.RS 4
This variable indicates that that the
f\&.warpto
function should deiconify any iconified windows it encounters\&. This is typically used to make a key binding that will pop a particular window (such as
xmh), no matter where it is\&. The default is for
f\&.warpto
to ignore iconified windows\&.
.RE
.PP
WindowBox [{ win\-list }]
.RS 4
creates a new window called a box, where all the client windows that match the windows list are opened in, instead of the root window\&. This is useful to group small windows in the same box (xload for instance)
.sp
.if n \{\
.RS 4
.\}
.nf
WindowBox "xloadbox" "320x100+0\-0" {
    "xload"
}
.fi
.if n \{\
.RE
.\}
.RE
.PP
WindowGeometries { win\-list }
.RS 4
Used to give a default geometry to some clients :
.sp
.if n \{\
.RS 4
.\}
.nf
WindowGeometries {
    "Mozilla*"       "1000x800+10+10"
    "jpilot*"        "800x600\-0\-0"
}
.fi
.if n \{\
.RE
.\}
.RE
.PP
WindowRegion geomstring vgrav hgrav { win\-list }
.RS 4
Similar to IconRegion, but for windows\&. Note that the
win\-list
is not optional\&.
.RE
.PP
WindowRing [{ win\-list }]
.RS 4
This variable specifies a list of windows along which the
f\&.warpring
function cycles\&. If no argument is given, all the windows are in the ring\&.
.RE
.PP
WindowRingExclude [{ win\-list }]
.RS 4
All listed windows will be excluded from the WarpRing\&.
.RE
.PP
WMgrButtonShadowDepth depth
.RS 4
Control the depth of the shadow of the workspace manager buttons\&.
.RE
.PP
WMgrButtonStyle string
.RS 4
Sets the style of the workspace manager buttons (when in button rather than map state), as well as the buttons in the Occupy window\&. Available options are
normal
(the default 3d look),
style1,
style2, and
style3
(which are slightly different 2d looks)\&.
.RE
.PP
WMgrHorizButtonIndent nb_pixels
.RS 4
Specifies the horizontal space, in pixel, between the buttons of the workspace manager (in button mode)\&.
.RE
.PP
WMgrVertButtonIndent nb_pixels
.RS 4
Specifies the vertical space, in pixel, between the buttons of the workspace manager (in button mode)\&.
.RE
.PP
WorkSpaceFont string
.RS 4
This allows you to specify the font to use for the small windows in the workspace manager map\&. (Try
\-adobe\-times\-*\-r\-*\-\-10\-*\-*\-*\-*\-*\-*\-*)\&.
.RE
.PP
WorkSpaceManagerGeometry string [ columns ]
.RS 4
This variable specifies the geometry of the workspace manager window\&. The
string
argument is standard geometry specification that indicates the initial full size of the workspace manager\&. The
columns
argument indicates the number of columns to use for the workspace manager window\&.
.sp
.if n \{\
.RS 4
.\}
.nf
WorkSpaceManagerGeometry        "360x60+60\-0" 8
.fi
.if n \{\
.RE
.\}
.RE
.PP
WorkSpaces { workspace\-list }
.RS 4
This variable specifies a list of workspaces that are created at startup, Where
workspace\-list
is :
.sp
.if n \{\
.RS 4
.\}
.nf
name [{bg\-button [fg\-button] [bg\-root] [fg\-root] [pixmap\-root]}]
.fi
.if n \{\
.RE
.\}
.sp
With:
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt
lt lt.
T{
bg\-button
T}:T{
background color of the corresponding button in the workspace manager\&.
T}
T{
fg\-button
T}:T{
foreground color of the corresponding button in the workspace manager\&.
T}
T{
bg\-root
T}:T{
background color of the corresponding root screen\&.
T}
T{
fg\-root
T}:T{
foreground color of the corresponding root screen\&.
T}
T{
pixmap\-root
T}:T{
pixmap to display on the corresponding root screen, either the name of a bitmap,
xpm:xpmfile,
xwd:xwdfile,
jpeg:jpgfile, or
|command_that generates_xwd\&.
T}
.TE
.sp 1
Example:
.sp
.if n \{\
.RS 4
.\}
.nf
WorkSpaces
{
  "One"   {"#686B9F" "white" "DeepSkyBlue3" "white" "jpeg:shark\&.jpg"}
  "Two"   {"#619AAE" "white" "firebrick"}
  "Three" {"#727786" "white" "MidnightBlue" "white" "xpm:ball%\&.xpm"}
  "Four"  {"#727786" "white" "white"        "white"
                                      "|(giftoppm | pnmtoxwd) < 2010\&.gif"}

  "Five"  {"#727786" "white" "DeepSkyBlue3" "white" "plaid"}
  "Six"   {"#619AAE" "white" "DeepSkyBlue3" "white" "xpm:background1"}
  "Seven" {"#8C5b7A" "white" "chartreuse4"}
  "Eight" {"#686B9F" "white" "MidnightBlue"}
}
.fi
.if n \{\
.RE
.\}
.sp
The WorkSpaces declaration should come before the Occupy or OccupyAll declarations\&. The maximum number of workspaces is 32\&.
.sp
Each workspace also has a label, which is displayed in the WorkSpaceManager window when it is in button state\&. By moving the mouse cursor over a button and typing letters and/or backspace, you may edit the label\&. The name is unaffected\&. Functions that look up workspaces by name also look at the label\&.
.RE
.PP
XMoveGrid number
.RS 4
This variable specifies the value to use to constrain window movement\&. When moving windows around, the x coordinate will always be a multiple of this variable\&. Default is 1\&. f\&.forcemove ignores this variable\&.
.RE
.PP
XorValue number
.RS 4
This variable specifies the value to use when drawing window outlines for moving and resizing\&. This should be set to a value that will result in a variety of distinguishable colors when exclusive\-or\(cqed with the contents of the user\(cqs typical screen\&. Setting this variable to 1 often gives nice results if adjacent colors in the default colormap are distinct\&. By default, ctwm will attempt to cause temporary lines to appear at the opposite end of the colormap from the graphics\&.
.RE
.PP
YMoveGrid number
.RS 4
This variable specifies the value to use to constrain window movement\&. When moving windows around, the y coordinate will always be a multiple of this variable\&. Default is 1\&. f\&.forcemove ignores this variable\&.
.RE
.PP
Zoom [ count ]
.RS 4
This variable indicates that outlines suggesting movement of a window to and from its iconified state should be displayed whenever a window is iconified or deiconified\&. The optional
count
argument specifies the number of outlines to be drawn\&. The default count is 8\&.
.RE
.sp
The following variables must be set after the fonts have been assigned, so it is usually best to put them at the end of the variables or beginning of the bindings sections:
.PP
ChangeWorkspaceFunction function
.RS 4
This variable specifies the function to be executed when the user change the current workspace (zap)\&.
.RE
.PP
DefaultFunction function
.RS 4
This variable specifies the function to be executed when a key or button event is received for which no binding is provided\&. This is typically bound to
f\&.nop,
f\&.beep, or a menu containing window operations\&.
.RE
.PP
DeIconifyFunction function
.RS 4
This variable specifies the function to be executed when a window is deiconified\&.
.RE
.PP
IconifyFunction function
.RS 4
This variable specifies the function to be executed when a window is iconified\&.
.RE
.PP
WindowFunction function
.RS 4
This variable specifies the function to execute when a window is selected from the
TwmWindows
menu\&. If this variable is not set, the window will be deiconified and raised\&.
.RE
.SH "BINDINGS"
.sp
After the desired variables have been set, functions may be attached to titlebuttons and key and pointer buttons\&. Titlebuttons may be added from the left or right side and appear in the titlebar from left\-to\-right according to the order in which they are specified\&. Key and pointer button bindings may be given in any order\&.
.SS "Title buttons"
.sp
Titlebuttons specifications must include the name of the pixmap to use in the button box and the function to be invoked when a pointer button is pressed within them:
.sp
.if n \{\
.RS 4
.\}
.nf
LeftTitleButton "bitmapname" = function
.fi
.if n \{\
.RE
.\}
.sp
or
.sp
.if n \{\
.RS 4
.\}
.nf
LeftTitleButton "bitmapname" {
    Buttoni = modlist : function
    \&.\&.\&.
    Buttonj = function
}
.fi
.if n \{\
.RE
.\}
.sp
or
.sp
.if n \{\
.RS 4
.\}
.nf
RightTitleButton "bitmapname" = function
.fi
.if n \{\
.RE
.\}
.sp
or
.sp
.if n \{\
.RS 4
.\}
.nf
RightTitleButton "bitmapname" {
    Buttoni = modlist : function
    \&.\&.\&.
    Buttonj = function
}
.fi
.if n \{\
.RE
.\}
.sp
The bitmapname may refer to one of the built\-in bitmaps (which are scaled to match TitleFont) by using the appropriate colon\-prefixed name described above\&.
.sp
The pointer button specifications come in two forms, with a modifier list or without\&. When the specification comes without a modifier list, it\(cqs used for the case when no modifiers are used\&. In other words, the following two lines are equivalent:
.sp
.if n \{\
.RS 4
.\}
.nf
    Buttoni = function
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
    Buttoni = : function
.fi
.if n \{\
.RE
.\}
.SS "Key and pointer buttons"
.sp
Key and pointer button specifications must give the modifiers that must be pressed, over which parts of the screen the pointer must be, and what function is to be invoked\&. Keys are given as strings containing the appropriate keysym name; buttons are given as the keywords Button1\-Button11:
.sp
.if n \{\
.RS 4
.\}
.nf
"FP1"   = modlist : context : function
Button1 = modlist : context : function
.fi
.if n \{\
.RE
.\}
.sp
A user who wanted to be able to manipulate windows from the keyboard could use the following bindings:
.sp
.if n \{\
.RS 4
.\}
.nf
"F1"    =       : all : f\&.iconify
"F2"    =       : all : f\&.raiselower
"F3"    =       : all : f\&.warpring "next"
"F4"    =       : all : f\&.warpto "xmh"
"F5"    =       : all : f\&.warpto "emacs"
"F6"    =       : all : f\&.colormap "next"
"F7"    =       : all : f\&.colormap "default"
"F20"   =       : all : f\&.warptoscreen "next"
"Left"  = m     : all : f\&.backiconmgr
"Right" = m | s : all : f\&.forwiconmgr
"Up"    = m     : all : f\&.upiconmgr
"Down"  = m | s : all : f\&.downiconmgr
.fi
.if n \{\
.RE
.\}
.sp
ctwm provides many more window manipulation primitives than can be conveniently stored in a titlebar, menu, or set of key bindings\&. Although a small set of defaults are supplied (unless the NoDefaults is specified), most users will want to have their most common operations bound to key and button strokes\&. To do this, ctwm associates names with each of the primitives and provides user\-defined functions for building higher level primitives and menus for interactively selecting among groups of functions\&.
.SS "Modifiers and Contexts"
.sp
The modlist allows specifying different bindings for a button or key when modifiers are applied\&. The list of recognized modifier names (abbreviated) are shift (s), control (c), lock (l), alter1 (a1), alter2 (a2), alter3 (a3), alter4 (a4), alter5 (a5), meta (m), mod1 (m1), mod2 (m2), mod3 (m3), mod4 (m4), and mod5 (m5)\&. Multiple modifiers may be applied to a single line by combining them with a vertical bar (|)\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
# Open the "top" menu with a Button1 (usually left mouse button) click in
# the root window
Button1 =        : root : f\&.menu "top"

# Open the "top2" menu with shift\-click
Button1 =     s  : root : f\&.menu "top2"

# And "top3" when control\-shift\-click
Button1 = c | s  : root : f\&.menu "top3"
.fi
.if n \{\
.RE
.\}
.sp
The lock modifier refers to CapsLock\&. meta is generally your Alt key\&. mod1 is the same as meta\&. mod2\&.\&.5 can have various special meanings; try running xmodmap \-pm to see how your X server is mapping things (the xkeycaps program may also be useful)\&. The alter1\&.\&.5 modifiers refer to ctwm alternate keymaps; see the description of f\&.altkeymap below for details\&.
.sp
Note that if you\(cqre using the m4 preprocessor, most implementations define a shift macro internally, so using that as a modifier will silently fail to work right\&. To get around it, you\(cqll need to quote it so that m4 passes it through as a literal string: `shift\*(Aq\&.
.sp
The context lets you specify which mappings apply based on where the pointer currently is on the screen\&. The available options are window (w), title (t), icon (i), root (r), frame (f), workspace (no abbreviation), iconmgr (m), and alter (a)\&. Like the modifiers above, they may be combined with a vertical bar, which allows you to bind an action in multiple contexts at once\&. Alternately, all can be given for the context to specify that the binding should happen everywhere\&. It\(cqs equivalent to combining all the choices (except alter, which is special)\&.
.sp
The alter context allows binding the function when in the alternate context; see the f\&.altcontext function below for details\&.
.sp
There is an additional possible magical value for context; if you provide a quoted string (e\&.g\&., "MyXterm") for the context of a key (but not button) binding, then that binding will trigger the given function in window context to all windows matching that name\&. e\&.g\&.,
.sp
.if n \{\
.RS 4
.\}
.nf
# Pressing "F1" anywhere on the screen will cause all windows with name
# "xterm" to raise themselves\&.
"F1" = : "xterm" : f\&.raise
.fi
.if n \{\
.RE
.\}
.sp
Beware that this can have odd side effects if multiple windows are matched, especially if the function can conflict one with the other (e\&.g\&., in the example above, if two "xterm" windows overlap each other)\&.
.SS "Functions"
.sp
The function in a binding is any of the f\&. keywords described below\&. For example, the default startup file contains the following bindings:
.sp
.if n \{\
.RS 4
.\}
.nf
Button1 =   : root          : f\&.menu "TwmWindows"
Button1 = m : window | icon : f\&.function "move\-or\-lower"
Button2 = m : window | icon : f\&.iconify
Button3 = m : window | icon : f\&.function "move\-or\-raise"
Button1 =   : title         : f\&.function "move\-or\-raise"
Button2 =   : title         : f\&.raiselower
Button1 =   : icon          : f\&.function "move\-or\-iconify"
Button2 =   : icon          : f\&.iconify
Button1 =   : iconmgr       : f\&.iconify
Button2 =   : iconmgr       : f\&.iconify
.fi
.if n \{\
.RE
.\}
.sp
User\-defined functions contain the name by which they are referenced in calls to f\&.function and a list of other functions to execute\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
Function "move\-or\-lower"    { f\&.move f\&.deltastop f\&.lower }
Function "move\-or\-raise"    { f\&.move f\&.deltastop f\&.raise }
Function "move\-or\-iconify"  { f\&.move f\&.deltastop f\&.iconify }
Function "restore\-colormap" { f\&.colormap "default" f\&.lower }
.fi
.if n \{\
.RE
.\}
.sp
The function name must be used in f\&.function exactly as it appears in the function specification\&.
.sp
In the descriptions below, if the function is said to operate on the selected window, but is invoked from a root menu, the cursor will be changed to the Select cursor and the next window to receive a button press will be chosen:
.PP
! string
.RS 4
This is an abbreviation for
f\&.exec
string\&.
.RE
.PP
f\&.addtoworkspace string
.RS 4
This function adds the selected window to the workspace whose name is
string\&.
.RE
.PP
f\&.adoptwindow
.RS 4
This function asks for the user to select a window with the mouse, and then adopt this window if it doesn\(cqt belong to the current ctwm\&. Useful only with the \-w flag\&.
.RE
.PP
f\&.altcontext
.RS 4
Set the alternate context\&. The next key or button event ctwm receives will be interpreted using the alternate context\&. To define bindings in the alternate context, use the keyword
alter
in the context field of the binding command\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
"Return" = m : all   : f\&.altcontext
"n" =        : alter : f\&.nextworkspace
"p" =        : alter : f\&.prevworkspace
.fi
.if n \{\
.RE
.\}
.RE
.PP
f\&.altkeymap number
.RS 4
Set the alternate keymap
number, where
number
is an integer between 1 and 5 inclusive\&. The next key or button event ctwm receives will be interpreted using this alternate keymap\&. To define bindings in an alternate keymap, use the keyword
a
followed by
number
in the modifier field of the binding command\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
"Return" = c : all                  : f\&.altkeymap "1"
"i" =     a1 : window|icon|iconmgr  : f\&.iconify
"z" =     a1 : window               : f\&.zoom
"d" =     a1 : window|icon          : f\&.delete
"o" =     a1 : window|icon          : f\&.occupy
"r" =     a1 : window|icon          : f\&.refresh
.fi
.if n \{\
.RE
.\}
.sp
When using an alternate keymaps, only the root, window, icon and iconmgr contexts are allowed\&.
.RE
.PP
f\&.autolower
.RS 4
This function toggles whether or not the selected window is lowered whenever the pointer leaves it\&. See the description of the variable
AutoLower\&.
.RE
.PP
f\&.autoraise
.RS 4
This function toggles whether or not the selected window is raised whenever entered by the pointer\&. See the description of the variable
AutoRaise\&.
.RE
.PP
f\&.backiconmgr
.RS 4
This function warps the pointer to the previous column in the current icon manager, wrapping back to the previous row if necessary\&.
.RE
.PP
f\&.backmapiconmgr
.RS 4
This function warps the pointer in the same manner as
f\&.backiconmgr
but only stops at windows that are mapped\&.
.RE
.PP
f\&.beep
.RS 4
This function sounds the keyboard bell\&.
.RE
.PP
f\&.bottomzoom
.RS 4
This function stretches the bottom side of the window out to the bottom edge of the screen, or restores the original size if the window was already bottomzoom\(cqd\&.
.RE
.PP
f\&.changepriority rel\-value
.RS 4
Change the priority of a window by
rel\-value
(enclosed within double quotes)\&. For instance, to bury a window one level down, you would use f\&.changepriority "\-1"\&. See
OnTopPriority
variable\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
f\&.changesize string
.RS 4
This function allows you to change the size of the focused window\&. The format of the string must be either
"<border> <+|\-><sizechange>"
(where
<border>
must be one of
top,
bottom,
left
or
right) or
"<x size>x<y size>"
(where the size is the requested new window size)\&. The height of the window can never be set/changed to less than the title height + 1 (or 1 if the window has no title) and the width can never be set/changed to less than 1\&.
.sp
.if n \{\
.RS 4
.\}
.nf
"Right"  = c|s : all : f\&.changesize "right +10"
"Left"   = c|s : all : f\&.changesize "right \-10"
"Down"   = c|s : all : f\&.changesize "bottom +10"
"Up"     = c|s : all : f\&.changesize "bottom \-10"

"F1"     = c|s : all : f\&.changesize "640x480"
"F2"     = c|s : all : f\&.changesize "800x600"
"F3"     = c|s : all : f\&.changesize "1024x768"
.fi
.if n \{\
.RE
.\}
.RE
.PP
f\&.circledown
.RS 4
This function lowers the top\-most window that occludes another window\&.
.RE
.PP
f\&.circleup
.RS 4
This function raises the bottom\-most window that is occluded by another window\&.
.RE
.PP
f\&.colormap string
.RS 4
This function rotates the colormaps (obtained from the
WM_COLORMAP_WINDOWS
property on the window) that ctwm will display when the pointer is in this window\&. The argument
string
may have one of the following values:
"next",
"prev", and
"default"\&. It should be noted here that in general, the installed colormap is determined by keyboard focus\&. A pointer driven keyboard focus will install a private colormap upon entry of the window owning the colormap\&. Using the click to type model, private colormaps will not be installed until the user presses a mouse button on the target window\&.
.RE
.PP
f\&.deiconify
.RS 4
This function deiconifies the selected window\&. If the window is not an icon, this function does nothing\&.
.RE
.PP
f\&.delete
.RS 4
This function sends the
WM_DELETE_WINDOW
message to the selected window if the client application has requested it through the
WM_PROTOCOLS
window property\&. The application is supposed to respond to the message by removing the indicated window\&. If the window has not requested
WM_DELETE_WINDOW
messages, the keyboard bell will be rung indicating that the user should choose an alternative method\&. Note this is very different from f\&.destroy\&. The intent here is to delete a single window, not necessarily the entire application\&.
.RE
.PP
f\&.deleteordestroy
.RS 4
First tries to delete the window (send it
WM_DELETE_WINDOW
message), or kills it, if the client doesn\(cqt accept such message\&.
.RE
.PP
f\&.deltastop
.RS 4
This function allows a user\-defined function to be aborted if the pointer has been moved more than
MoveDelta
pixels\&. See the example definition given for
Function "move\-or\-raise"
at the beginning of the section\&.
.RE
.PP
f\&.destroy
.RS 4
This function instructs the X server to close the display connection of the client that created the selected window\&. This should only be used as a last resort for shutting down runaway clients\&. See also f\&.delete\&.
.RE
.PP
f\&.downiconmgr
.RS 4
This function warps the pointer to the next row in the current icon manger, wrapping to the beginning of the next column if necessary\&.
.RE
.PP
f\&.downworkspace
.RS 4
Goto the workspace immediately underneath the current workspace in the workspace manager\&. If the current workspace is the bottom one, goto the top one in the same column\&. The result depends on the layout of the workspace manager\&.
.RE
.PP
f\&.exec string
.RS 4
This function passes the argument
string
to
/bin/sh
for execution\&. In multiscreen mode, if
string
starts a new X client without giving a display argument, the client will appear on the screen from which this function was invoked\&. If the string \(lq$currentworkspace\(rq is present inside the string argument, it will be substituted with the current workspace name\&.
.RE
.PP
f\&.fill string
.RS 4
Where string is either : \(lqright\(rq, \(lqleft\(rq, \(lqtop\(rq, \(lqbottom\(rq or \(lqvertical\(rq\&. The current window is resized in the specified direction until it reaches an obstacle (either another window, or the screen border)\&. f\&.fill \(lqvertical\(rq sets the window status to \(lqzoomed\(rq and toggles, ie calling it again will reset the previous window size\&.
.RE
.PP
f\&.fittocontent
.RS 4
Can be used only with window boxes\&. The result is to have the box have the minimal size that contains all its children windows\&.
.RE
.PP
f\&.focus
.RS 4
This function toggles the keyboard focus of the server to the selected window, changing the focus rule from pointer\-driven if necessary\&. If the selected window already was focused, this function executes an
f\&.unfocus\&.
.RE
.PP
f\&.forcemove
.RS 4
This function is like
f\&.move
except that it ignores the
DontMoveOff
variable\&.
.RE
.PP
f\&.forwiconmgr
.RS 4
This function warps the pointer to the next column in the current icon manager, wrapping to the beginning of the next row if necessary\&.
.RE
.PP
f\&.forwmapiconmgr
.RS 4
This function warps the pointer in the same manner as
f\&.forwiconmgr
but only stops at windows that are mapped\&.
.RE
.PP
f\&.fullscreenzoom
.RS 4
This function is similar to the
f\&.fullzoom
function, except that it makes the client window (the part inside the frame) the size of the screen, so the window decorations are off\-screen\&. This gives the same visual effect as the window covering the whole screen with no decorations\&. If the window is already fullscreenzoom\(cqd, it restores the original size\&.
.RE
.PP
f\&.fullzoom
.RS 4
This function resizes the selected window to the full size of the screen, or restores the original size if the window was already fullzoom\(cqd\&.
.RE
.PP
f\&.function string
.RS 4
This function executes the user\-defined function whose name is specified by the argument
string\&.
.RE
.PP
f\&.gotoworkspace workspace_name
.RS 4
This function warps you to the workspace whose name is
workspace_name\&.
.RE
.PP
f\&.hbzoom
.RS 4
This function is a synonym for
f\&.bottomzoom\&.
.RE
.PP
f\&.hideiconmgr
.RS 4
This function unmaps the current icon manager\&.
.RE
.PP
f\&.hideworkspacemgr
.RS 4
Unmap the WorkSpace manager\&.
.RE
.PP
f\&.horizoom
.RS 4
This function stretches the window so that it covers the whole width of the screen, or restores the original size if the window was already horizoom\(cqd\&.
.RE
.PP
f\&.htzoom
.RS 4
This function is a synonym for
f\&.topzoom\&.
.RE
.PP
f\&.hypermove
.RS 4
Use this function to \(lqmove\(rq a window between 2 captives ctwm (or between a captive and the root ctwm)\&. Of course 2 ctwms are completely different universes\&. You have to go in hyperspace to achieve this, hence the name\&.
.RE
.PP
f\&.hzoom
.RS 4
This function is a synonym for
f\&.horizoom\&.
.RE
.PP
f\&.iconify
.RS 4
This function iconifies or deiconifies the selected window or icon, respectively\&.
.RE
.PP
f\&.identify
.RS 4
This function displays a summary of the name and geometry of the selected window\&. Clicking the pointer or pressing a key in the window will dismiss it\&.
.RE
.PP
f\&.initsize
.RS 4
This function resets a window to its initial size given by the
WM_NORMAL_HINTS
hints\&.
.RE
.PP
f\&.jumpdown step
.RS 4
This function is designed to be bound to a key, it moves the current window (step * {X,Y}MoveGrid) pixels downward\&. stopping if the window encounters another window or the screen border (ala f\&.pack)\&.
.RE
.PP
f\&.jumpleft step
.RS 4
Leftward equivalent of f\&.jumpdown\&.
.RE
.PP
f\&.jumpright step
.RS 4
Rightward equivalent of f\&.jumpdown\&.
.RE
.PP
f\&.jumpup step
.RS 4
Upward equivalent of f\&.jumpdown\&.
.RE
.PP
f\&.lefticonmgr
.RS 4
This function similar to
f\&.backiconmgr
except that wrapping does not change rows\&.
.RE
.PP
f\&.leftworkspace
.RS 4
Goto the workspace immediately on the left of the current workspace in the workspace manager\&. If the current workspace is the leftest one, goto the rightest one in the same row\&. The result depends on the layout of the workspace manager\&.
.RE
.PP
f\&.leftzoom
.RS 4
This function stretches the left side of the window out to the left edge of the screen, or restores the original size if the window was already leftzoom\(cqd\&.
.RE
.PP
f\&.lower
.RS 4
This function lowers the selected window\&.
.RE
.PP
f\&.menu string
.RS 4
This function invokes the menu specified by the argument
string\&. Cascaded menus may be built by nesting calls to
f\&.menu\&. When a menu is popped up, you can use the arrow keys to move the cursor around it\&. \(lqDown\(rq or space goes down, \(lqUp\(rq goes up, \(lqLeft\(rq pops down the menu, and \(lqRight\(rq activates the current entry\&. The first letter of an entry name activates this entry (the first one if several entries match)\&. If the first letter is ~ then Meta\-the\-second\-letter activates it, if this first letter is ^ then Control\-the\-second\-letter activates it, and if this first letter is space, then the second letter activates it\&.
.RE
.PP
f\&.move
.RS 4
This function drags an outline of the selected window (or the window itself if the
OpaqueMove
variable is set) until the invoking pointer button is released\&. Double clicking within the number of milliseconds given by
ConstrainedMoveTime
warps the pointer to the center of the window and constrains the move to be either horizontal or vertical depending on which grid line is crossed\&. To abort a move, press another button before releasing the first button\&.
.RE
.PP
f\&.movepack
.RS 4
This function is like
f\&.move
except that it tries to avoid overlapping of windows\&. When the moving window begin to overlap with another window, the move is stopped\&. If you go too far over the other window (more that
MovePackResistance
pixels), the move is resumed and the moving window can overlap with the other window\&. Useful to pack windows closely\&.
.RE
.PP
f\&.movepush
.RS 4
This function is like
f\&.move
except that it tries to avoid overlapping of windows\&. When the moving window begins to overlap with another window, the other window is pushed\&. If you go too far over the other window (more that
MovePackResistance
pixels), there is no push and the moving window can overlap with the other window\&. Only available if
OpaqueMove
is active\&.
.RE
.PP
f\&.moveresize geometry
.RS 4
Takes one string argument which is a geometry with the standard X geometry syntax (e\&.g\&. 200x300+150\-0)\&. Sets the current window to the specified geometry\&. The width and height are to be given in pixel, no base size or resize increment are used\&.
.RE
.PP
f\&.movetitlebar
.RS 4
If applied to a squeezed titlebar (see
SqueezeTitle) you can drag it along the top of the window (a feature which was first found in BeOS)\&. The existing justification type is preserved, as is the positioning (relative or absolute)\&. This means that a relatively positioned titlebar will move when the width of a window changes, whereas an absolutely positioned title will not\&. The default positioning is left\-justified, absolute at 0 pixels\&.
.sp
.if n \{\
.RS 4
.\}
.nf
Button1 = m1 : title : f\&.movetitlebar
.fi
.if n \{\
.RE
.\}
.sp
f\&.movetitlebar
does nothing if the window has no title, the window is squeezed (see f\&.squeeze), or the title is not squeezed (see
SqueezeTitle)\&.
.RE
.PP
f\&.movetonextworkspace, f\&.movetonextworkspaceandfollow
.RS 4
Move the window to the next workspace, and optionally switch view over to that workspace\&.
.RE
.PP
f\&.movetoprevworkspace, f\&.movetoprevworkspaceandfollow
.RS 4
Move the window to the previous workspace, and optionally switch view over to that workspace\&.
.RE
.PP
f\&.nexticonmgr
.RS 4
This function warps the pointer to the next icon manager containing any windows on the current or any succeeding screen\&.
.RE
.PP
f\&.nextworkspace
.RS 4
Goto the next workspace in the list, using the order given in the
\&.ctwmrc
file\&.
.RE
.PP
f\&.nop
.RS 4
This function does nothing and is typically used with the
DefaultFunction
or
WindowFunction
variables or to introduce blank lines in menus\&.
.RE
.PP
f\&.occupy
.RS 4
This function pops up a window for the user to choose which workspaces a window belongs to\&.
.RE
.PP
f\&.occupyall
.RS 4
This function makes the specified window occupy all the workspaces\&.
.RE
.PP
f\&.pack string
.RS 4
Where string is either : \(lqright\(rq, \(lqleft\(rq, \(lqtop\(rq or \(lqbottom\(rq The current window is moved in the specified direction until it reaches an obstacle (either another window, or the screen border)\&. The pointer follows the window\&.
.RE
.PP
f\&.pin
.RS 4
Valid only in a root menu\&. Make a menu permanent on the screen\&. This is a toggle function, if you select it while the menu is already permanent, it becomes non\-permanent\&.
.RE
.PP
f\&.previconmgr
.RS 4
This function warps the pointer to the previous icon manager containing any windows on the current or preceding screens\&.
.RE
.PP
f\&.prevworkspace
.RS 4
Goto the previous workspace in the list, using the order given in the
\&.ctwmrc
file\&.
.RE
.PP
f\&.priorityswitching
.RS 4
Toggle the window\(cqs switching ability\&. X\-ref
PrioritySwitching
and
OnTopPriority
variables\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
f\&.quit
.RS 4
This function causes ctwm to restore the window\(cqs borders and exit\&. If ctwm is the first client invoked from
xdm, this will result in a server reset\&.
.RE
.PP
f\&.raise
.RS 4
This function raises the selected window\&.
.RE
.PP
f\&.raiseicons
.RS 4
This function raises all the icons in the current workspace\&.
.RE
.PP
f\&.raiselower
.RS 4
This function raises the selected window to the top of the stacking order if it is occluded by any windows, otherwise the window will be lowered\&.
.RE
.PP
f\&.raiseorsqueeze
.RS 4
Raise the window or squeeze it if it\(cqs a double click\&. The time that defines a double click is given by the
ConstrainedMoveTime
variable\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
f\&.refresh
.RS 4
This function causes all windows to be refreshed\&.
.RE
.PP
f\&.removefromworkspace string
.RS 4
This function removes the selected window from the workspace whose name is
string\&.
.RE
.PP
f\&.rereadsounds
.RS 4
This function causes the
\&.ctwm\-sounds
file to be re\-read\&. Note that this will
\fBnot\fR
re\-read sounds set in
RplaySounds
in the config file\&. As a result, this function will probably go away in the future when
\&.ctwm\-sounds
support is removed\&. See the SOUNDS section\&.
.RE
.PP
f\&.rescuewindows
.RS 4
If you somehow managed to move a window out of sight, calling this function will check all windows and icons on currently visible virtual screens, and those that are (nearly) out of the bounds of their virtual screen will be brought completely inside (if that fits)\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
f\&.resize
.RS 4
This function displays an outline of the selected window\&. Crossing a border (or setting
AutoRelativeResize) will cause the outline to begin to rubber band until the invoking button is released\&. To abort a resize, press another button before releasing the first button\&.
.RE
.PP
f\&.restart
.RS 4
This function kills and restarts ctwm\&.
.RE
.PP
f\&.restoregeometry
.RS 4
Restore the current window geometry to what was saved in the last call to f\&.savegeometry\&.
.RE
.PP
f\&.righticonmgr
.RS 4
This function is similar to
f\&.nexticonmgr
except that wrapping does not change rows\&.
.RE
.PP
f\&.rightworkspace
.RS 4
Goto the workspace immediately on the right of the current workspace in the workspace manager\&. If the current workspace is the rightest one, goto the leftest one in the same row\&. The result depends on the layout of the workspace manager\&.
.RE
.PP
f\&.rightzoom
.RS 4
This function stretches the right side of the window out to the right edge of the screen, or restores the original size if the window was already rightzoom\(cqd\&.
.RE
.PP
f\&.ring
.RS 4
Selects a window and adds it to the WarpRing, or removes it if it was already in the ring\&. This command makes
f\&.warpring
much more useful, by making its configuration dynamic\&.
.RE
.PP
f\&.savegeometry
.RS 4
The geometry of the current window is saved\&. The next call to f\&.restoregeometry will restore this window to this geometry\&.
.RE
.PP
f\&.saveyourself
.RS 4
This function sends a
WM_SAVEYOURSELF
message to the selected window if it has requested the message in its
WM_PROTOCOLS
window property\&. Clients that accept this message are supposed to checkpoint all state associated with the window and update the
WM_COMMAND
property as specified in the ICCCM\&. If the selected window has not selected for this message, the keyboard bell will be rung\&.
.RE
.PP
f\&.separator
.RS 4
Valid only in menus\&. The effect is to add a line separator between the previous and the following entry\&. The name selector part in the menu is not used (but must be present)\&.
.RE
.PP
f\&.setbuttonsstate
.RS 4
Set the WorkSpace manager in button state\&.
.RE
.PP
f\&.setmapstate
.RS 4
Set the WorkSpace manager in map state\&.
.RE
.PP
f\&.setpriority "value"
.RS 4
Set the window\(cqs priority to
value
(enclosed between double quotes)\&. If
value
is directly followed by
<
or
b, the window is placed below other windows of the given priority\&. Otherwise it is placed above\&. See
OnTopPriority
variable for details\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
f\&.showbackground
.RS 4
This function unmaps all windows in the current workspace\&. This is a toggle function, if all windows are unmapped, they are all remapped\&. Better bind this function in the root context\&.
.RE
.PP
f\&.showiconmgr
.RS 4
This function maps the current icon manager\&.
.RE
.PP
f\&.showworkspacemgr
.RS 4
Map the WorkSpace manager\&.
.RE
.PP
f\&.slowdownanimation
.RS 4
Decrease
AnimationSpeed
by 1\&.
.RE
.PP
f\&.sorticonmgr
.RS 4
This function sorts the entries in the current icon manager alphabetically\&. See the variable
SortIconManager\&.
.RE
.PP
f\&.speedupanimation
.RS 4
Increase
AnimationSpeed
by 1\&.
.RE
.PP
f\&.squeeze
.RS 4
f\&.squeeze squeezes a window to a null vertical size\&. Works only for windows with either a title, or a 3D border (in order to have something left on the screen)\&. If the window is already squeezed, it is unsqueezed\&.
.RE
.PP
f\&.startanimation
.RS 4
Restart freezed animations (if any)\&.
.RE
.PP
f\&.stopanimation
.RS 4
Freeze animations (if any)\&.
.RE
.PP
f\&.switchpriority
.RS 4
Switch the window\(cqs priority, independently of its ability to switch automatically\&. X\-ref
OnTopPriority
and
PrioritySwitching
variables\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
f\&.tinylower, f\&.tinyraise
.RS 4
These two functions allow you to raise/lower a window "one step" at a time\&. For instance,
f\&.tinyraise
will bring the current window just above the lowest one that\(cqs hiding it\&. These two functions are not subject to priority\-switching\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
f\&.title
.RS 4
This function provides a centered, unselectable item in a menu definition\&. It should not be used in any other context\&.
.RE
.PP
f\&.toggleoccupation string
.RS 4
This function adds the selected window to the workspace whose name is
string
if it doesn\(cqt already belongs to it, and removes it from this workspace if not\&.
.RE
.PP
f\&.togglesound
.RS 4
Toggle sound on/off\&. See the SOUNDS section\&.
.RE
.PP
f\&.togglestate
.RS 4
Toggle the state of the WorkSpace manager\&.
.RE
.PP
f\&.toggleworkspacemgr
.RS 4
Toggle the presence of the WorkSpaceManager\&. If it is mapped, it will be unmapped and vice versa\&.
.RE
.PP
f\&.topzoom
.RS 4
This function stretches the top side of the window out to the top edge of the screen, or restores the original size if the window was already topzoom\(cqd\&.
.RE
.PP
f\&.trace string
.RS 4
Used for handling dumping debug output\&. If a filename is given in
string, begins writing output to that file; if
string
is
"stderr"
writes to stderr\&. If debug file is already open, calling f\&.trace again closes it\&.
.sp
This is probably only useful if you\(cqre doing development on ctwm\&.
.RE
.PP
f\&.twmrc
.RS 4
Alias for
f\&.restart\&.
.RE
.PP
f\&.unfocus
.RS 4
This function resets the focus back to pointer\-driven\&. This should be used when a focused window is no longer desired\&.
.RE
.PP
f\&.unsqueeze
.RS 4
Is to
f\&.squeeze
what
f\&.deiconify
is to
f\&.iconify\&.
.sp
First appeared in 4\&.0\&.0\&.
.RE
.PP
f\&.upiconmgr
.RS 4
This function warps the pointer to the previous row in the current icon manager, wrapping to the last row in the same column if necessary\&.
.RE
.PP
f\&.upworkspace
.RS 4
Goto the workspace immediately above the current workspace in the workspace manager\&. If the current workspace is the top one, goto the bottom one in the same column\&. The result depends on the layout of the workspace manager\&.
.RE
.PP
f\&.vanish
.RS 4
The specified window vanishes from the current workspace if it occupies at least one other WorkSpace\&. Do nothing in the others cases\&.
.RE
.PP
f\&.version
.RS 4
This function causes the ctwm version window to be displayed\&. This window will be displayed until a pointer button is pressed or the pointer is moved from one window to another\&.
.RE
.PP
f\&.vlzoom
.RS 4
This function is a synonym for
f\&.leftzoom\&.
.RE
.PP
f\&.vrzoom
.RS 4
This function is a synonym for
f\&.rightzoom\&.
.RE
.PP
f\&.warphere win_name
.RS 4
This function adds the window which has a name or class that matches string to the current workspace and warps the pointer to it\&. If the window is iconified, it will be deiconified if the variable WarpUnmapped is set or else ignored\&.
.RE
.PP
f\&.warpring string
.RS 4
This function warps the pointer to the next or previous window (as indicated by the argument
string, which may be
"next"
or
"prev") specified in the
WindowRing
variable\&.
.RE
.PP
f\&.warpto string
.RS 4
This function warps the pointer to the window which has a name or class that matches
string\&. If the window is iconified, it will be deiconified if the variable
WarpUnmapped
is set or else ignored\&.
.RE
.PP
f\&.warptoiconmgr string
.RS 4
This function warps the pointer to the icon manager entry associated with the window containing the pointer in the icon manager specified by the argument
string\&. If
string
is empty (i\&.e\&. ""), the current icon manager is chosen\&.
.RE
.PP
f\&.warptoscreen string
.RS 4
This function warps the pointer to the screen specified by the argument
string\&. The argument may be a number (e\&.g\&.
"0"
or
"1"), the word
"next"
(indicating the current screen plus 1, skipping over any unmanaged screens), the word
"back"
(indicating the current screen minus 1, skipping over any unmanaged screens), or the word
"prev"
(indicating the last screen visited)\&.
.RE
.PP
f\&.winrefresh
.RS 4
This function is similar to the
f\&.refresh
function except that only the selected window is refreshed\&.
.RE
.PP
f\&.zoom
.RS 4
This function stretches the window so that it covers the whole height of the screen, or restores the original size if the window was already zoom\(cqd\&. It\(cqs the vertical counterpart fo
f\&.horizoom; perhaps
f\&.vertzoom
would be a better name\&...
.RE
.SH "MENUS"
.sp
Functions may be grouped and interactively selected using pop\-up (when bound to a pointer button) or pull\-down (when associated with a titlebutton) menus\&. Each menu specification contains the name of the menu as it will be referred to by f\&.menu, optional default foreground and background colors, the list of item names and the functions they should invoke, and optional foreground and background colors for individual items:
.sp
.if n \{\
.RS 4
.\}
.nf
Menu "menuname" [ ("deffg":"defbg") ]
{
    string1  [ ("fg1":"bg1") ]  function1
    string2  [ ("fg2":"bg2") ]  function2
        \&.
        \&.
        \&.
    stringN  [ ("fgN":"bgN") ]  functionN
}
.fi
.if n \{\
.RE
.\}
.sp
The menuname is case\-sensitive\&. The optional deffg and defbg arguments specify the foreground and background colors used on a color display to highlight menu entries\&. The string portion of each menu entry will be the text which will appear in the menu\&. The optional fgN and bgN arguments specify the foreground and background colors of the menu entry when the pointer is not in the entry\&. These colors will only be used on a color display\&. The default is to use the colors specified by the MenuForeground and MenuBackground variables\&. The function portion of the menu entry is one of the functions, including any user\-defined functions, or additional menus\&.
.sp
If an entry name begins with a \(lq*\(rq (star), this star won\(cqt be displayed and the corresponding entry will be the default entry for this menu\&. When a menu has a default entry and is used as a submenu of another menu, this default entry action will be executed automatically when this submenu is selected without being displayed\&. It\(cqs hard to explain, but easy to understand\&.
.SS "Special Menus"
.sp
There are several special menus\&.
.sp
TwmWindows contains the names of all of the client and ctwm\-supplied windows in the current workspace\&. Selecting an entry will cause the WindowFunction to be executed on that window\&. If WindowFunction hasn\(cqt been set, the window will be deiconified and raised\&.
.sp
TwmVisible lists those windows which are currently deiconified (first appeared in 3\&.7)\&. TwmIcons lists only those which are currently iconified\&.
.sp
TwmAllWindows and TwmAllIcons act similarly to the non\-All variants described above, except that they show windows in all workspaces, rather than just the current one\&.
.sp
TwmWorkspaces contains the names of your workspaces, selecting an entry goto this workspace\&. In addition, these entries have submenus containing the names of all windows occupying this workspace, selecting such an entry executes f\&.warpto on this window\&.
.sp
TwmKeys lists all the keybindings in the root context that invoke f\&.exec\&. First appeared in 3\&.7\&.
.SH "ICONS"
.sp
ctwm supports several different ways of manipulating iconified windows\&. The common pixmap\-and\-text style may be laid out by hand or automatically arranged as described by the IconRegion variable\&. In addition, a terse grid of icon names, called an icon manager, provides a more efficient use of screen space as well as the ability to navigate among windows from the keyboard\&.
.sp
An icon manager is a window that contains names of selected or all windows currently on the display\&. In addition to the window name, a small button using the default iconify symbol will be displayed to the left of the name when the window is iconified\&. By default, clicking on an entry in the icon manager performs f\&.iconify\&. To change the actions taken in the icon manager, use the the iconmgr context when specifying button and keyboard bindings\&.
.sp
Moving the pointer into the icon manager also directs keyboard focus to the indicated window (setting the focus explicitly or else sending synthetic events NoTitleFocus is set)\&. Using the f\&.upiconmgr, f\&.downiconmgr f\&.lefticonmgr, and f\&.righticonmgr functions, the input focus can be changed between windows directly from the keyboard\&.
.SH "X WINDOW PROPERTIES"
.sp
As a window manager, ctwm reads and sets a huge variety of properties on the windows it manages and the windows it creates\&. Most of that is beyond the scope of user documentation\&. However, a few points are worth mentioning\&.
.SS "Window Naming"
.sp
Windows get their names via X properties\&. There are two types of names; the window name (which is what shows up in the titlebar, the f\&.identify window, etc), and the icon name (which shows up on the icon and on the icon manager)\&.
.sp
Prior to 4\&.0\&.2, ctwm only supported the standard ICCCM properties for setting the window and icon names\&. These are WM_NAME for the window name, and WM_ICON_NAME for the icon name\&. As of 4\&.0\&.2, ctwm also supports the EWMH versions of these, which are _NET_WM_NAME and _NET_WM_ICON_NAME\&. If the EWMH variants exist, they\(cqre used in preference to the older ICCCM style\&.
.sp
As of 4\&.0\&.2, ctwm also supports an additional pair of properties; CTWM_WM_NAME and CTWM_WM_ICON_NAME, which override all the others\&. These are specifically intended for the user to manually set, not for programs to set themselves\&. This allows the user to override programs that name themselves unhelpfully, or to otherwise label things to their liking\&.
.sp
You can set these via any method you\(cqd use to set window properties\&. From the command line, the xprop(1) tool is widely available, if a little clunky\&. So, for instance, to set the icon name of a window (changing how it looks in the icon manager), but leave the window name alone as the program itself normally sets it (leaving the titlebar normal), you could run a command like:
.sp
.if n \{\
.RS 4
.\}
.nf
xprop \-f CTWM_WM_ICON_NAME 8u \-set CTWM_WM_ICON_NAME "I hate this window"
.fi
.if n \{\
.RE
.\}
.sp
and then click the window you want to set it on\&. Unfortunately, xprop(1) does require you to specify the property name when defining the format, as well as when setting it, so it\(cqs a little ugly\&. The 8u means you\(cqre giving a UTF\-8 string\&. Other possible formats are 8s for a plain 7\-bit STRING (i\&.e, plain ASCII), and 8t for \(lqinternationalized\(rq ICCCM\-style COMPOUND_TEXT\&. Usually you\(cqd just use UTF\-8 though\&. xprop \-remove CTWM_WM_ICON_NAME and click would let you undo it and go back to the normal naming\&. See the xprop(1) manual for more\&.
.SH "SOUNDS"
.sp
If built with the USE_SOUND option, ctwm is able to play sounds for any X event\&. This may be configured in two ways\&.
.sp
As of 4\&.0\&.0, the sounds may be configured in the ctwmrc with the RplaySounds config parameter\&. See above for details\&.
.sp
If that is not found, or in older versions, ctwm will look for the file \&.ctwm\-sounds in the user\(cqs home directory to map every X event to a sound file to be played\&. Each line in \&.ctwm\-sounds has the following syntax:
.sp
.if n \{\
.RS 4
.\}
.nf
{X event}: {sound file}
.fi
.if n \{\
.RE
.\}
.sp
If RplaySounds is given in the config file, and \&.ctwm\-sounds exists, a warning will be given, and the contents of \&.ctwm\-sounds will be ignored\&. All support for \&.ctwm\-sounds will be removed in a future version, leaving only the ctwmrc configuration method available
.sp
However configured, the currently known X events that can be given are:
.sp
.if n \{\
.RS 4
.\}
.nf
KeyPress
KeyRelease
ButtonPress
ButtonRelease
MotionNotify
EnterNotify
LeaveNotify
FocusIn
FocusOut
KeymapNotify
Expose
GraphicsExpose
NoExpose
VisibilityNotify
CreateNotify
DestroyNotify
UnmapNotify
MapNotify
MapRequest
ReparentNotify
ConfigureNotify
ConfigureRequest
GravityNotify
ResizeRequest
CirculateNotify
CirculateRequest
PropertyNotify
SelectionClear
SelectionRequest
SelectionNotify
ColormapNotify
ClientMessage
MappingNotify
.fi
.if n \{\
.RE
.\}
.sp
Additionally, the following two are recognised, and represent the time when ctwm is started or shut down:
.sp
.if n \{\
.RS 4
.\}
.nf
Startup
Shutdown
.fi
.if n \{\
.RE
.\}
.SH "BUGS"
.sp
The resource manager should have been used instead of all of the window lists\&.
.sp
Double clicking very fast to get the constrained move function will sometimes cause the window to move, even though the pointer is not moved\&.
.sp
If IconifyByUnmapping is on and windows are listed in IconManagerDontShow but not in DontIconifyByUnmapping, they may be lost if they are iconified and no bindings to f\&.menu "TwmWindows" or f\&.warpto are setup\&.
.SH "FILES"
.sp
See earlier Customization section\&.
.SH "ENVIRONMENT VARIABLES"
.PP
DISPLAY
.RS 4
This variable is used to determine which X server to use\&. It is also set during
f\&.exec
so that programs come up on the proper screen\&.
.RE
.PP
HOME
.RS 4
This variable is used as the prefix for files that begin with a tilde and for locating the ctwm startup file\&.
.RE
.SH "SEE ALSO"
.sp
X(1), Xserver(1), xdm(1), xrdb(1)
.SH "COPYRIGHT"
.sp
Portions copyright 1988 Evans & Sutherland Computer Corporation; portions copyright 1989 Hewlett\-Packard Company and the Massachusetts Institute of Technology, See X(1) for a full statement of rights and permissions\&.
.sp
See COPYRIGHT file in distribution for more information\&.
.SH "AUTHORS"
.SS "TWM"
.sp
Tom LaStrange, Solbourne Computer; Jim Fulton, MIT X Consortium; Steve Pitschke, Stardent Computer; Keith Packard, MIT X Consortium; Dave Sternlicht, MIT X Consortium; Dave Payne, Apple Computer\&.
.SS "CTWM"
.sp
Claude Lecommandeur, Swiss Polytechnical Institute of Lausanne (lecom@sic\&.epfl\&.ch); Richard Levitte (richard@levitte\&.org); Matthew Fuller (fullermd@over\-yonder\&.net); and many other contributors\&.
.SH "VERSION"
.sp
This manual is build for ctwm 4\&.0\&.3\&.
